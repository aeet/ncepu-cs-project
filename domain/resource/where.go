// Code generated by ent, DO NOT EDIT.

package resource

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/devcui/ncepu-cs-project/domain/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Resource {
	return predicate.Resource(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Resource {
	return predicate.Resource(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Resource {
	return predicate.Resource(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Resource {
	return predicate.Resource(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Resource {
	return predicate.Resource(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Resource {
	return predicate.Resource(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Resource {
	return predicate.Resource(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Resource {
	return predicate.Resource(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Resource {
	return predicate.Resource(sql.FieldLTE(FieldID, id))
}

// ResourceName applies equality check predicate on the "resource_name" field. It's identical to ResourceNameEQ.
func ResourceName(v string) predicate.Resource {
	return predicate.Resource(sql.FieldEQ(FieldResourceName, v))
}

// ResourceValue applies equality check predicate on the "resource_value" field. It's identical to ResourceValueEQ.
func ResourceValue(v string) predicate.Resource {
	return predicate.Resource(sql.FieldEQ(FieldResourceValue, v))
}

// ResourceNameEQ applies the EQ predicate on the "resource_name" field.
func ResourceNameEQ(v string) predicate.Resource {
	return predicate.Resource(sql.FieldEQ(FieldResourceName, v))
}

// ResourceNameNEQ applies the NEQ predicate on the "resource_name" field.
func ResourceNameNEQ(v string) predicate.Resource {
	return predicate.Resource(sql.FieldNEQ(FieldResourceName, v))
}

// ResourceNameIn applies the In predicate on the "resource_name" field.
func ResourceNameIn(vs ...string) predicate.Resource {
	return predicate.Resource(sql.FieldIn(FieldResourceName, vs...))
}

// ResourceNameNotIn applies the NotIn predicate on the "resource_name" field.
func ResourceNameNotIn(vs ...string) predicate.Resource {
	return predicate.Resource(sql.FieldNotIn(FieldResourceName, vs...))
}

// ResourceNameGT applies the GT predicate on the "resource_name" field.
func ResourceNameGT(v string) predicate.Resource {
	return predicate.Resource(sql.FieldGT(FieldResourceName, v))
}

// ResourceNameGTE applies the GTE predicate on the "resource_name" field.
func ResourceNameGTE(v string) predicate.Resource {
	return predicate.Resource(sql.FieldGTE(FieldResourceName, v))
}

// ResourceNameLT applies the LT predicate on the "resource_name" field.
func ResourceNameLT(v string) predicate.Resource {
	return predicate.Resource(sql.FieldLT(FieldResourceName, v))
}

// ResourceNameLTE applies the LTE predicate on the "resource_name" field.
func ResourceNameLTE(v string) predicate.Resource {
	return predicate.Resource(sql.FieldLTE(FieldResourceName, v))
}

// ResourceNameContains applies the Contains predicate on the "resource_name" field.
func ResourceNameContains(v string) predicate.Resource {
	return predicate.Resource(sql.FieldContains(FieldResourceName, v))
}

// ResourceNameHasPrefix applies the HasPrefix predicate on the "resource_name" field.
func ResourceNameHasPrefix(v string) predicate.Resource {
	return predicate.Resource(sql.FieldHasPrefix(FieldResourceName, v))
}

// ResourceNameHasSuffix applies the HasSuffix predicate on the "resource_name" field.
func ResourceNameHasSuffix(v string) predicate.Resource {
	return predicate.Resource(sql.FieldHasSuffix(FieldResourceName, v))
}

// ResourceNameEqualFold applies the EqualFold predicate on the "resource_name" field.
func ResourceNameEqualFold(v string) predicate.Resource {
	return predicate.Resource(sql.FieldEqualFold(FieldResourceName, v))
}

// ResourceNameContainsFold applies the ContainsFold predicate on the "resource_name" field.
func ResourceNameContainsFold(v string) predicate.Resource {
	return predicate.Resource(sql.FieldContainsFold(FieldResourceName, v))
}

// ResourceValueEQ applies the EQ predicate on the "resource_value" field.
func ResourceValueEQ(v string) predicate.Resource {
	return predicate.Resource(sql.FieldEQ(FieldResourceValue, v))
}

// ResourceValueNEQ applies the NEQ predicate on the "resource_value" field.
func ResourceValueNEQ(v string) predicate.Resource {
	return predicate.Resource(sql.FieldNEQ(FieldResourceValue, v))
}

// ResourceValueIn applies the In predicate on the "resource_value" field.
func ResourceValueIn(vs ...string) predicate.Resource {
	return predicate.Resource(sql.FieldIn(FieldResourceValue, vs...))
}

// ResourceValueNotIn applies the NotIn predicate on the "resource_value" field.
func ResourceValueNotIn(vs ...string) predicate.Resource {
	return predicate.Resource(sql.FieldNotIn(FieldResourceValue, vs...))
}

// ResourceValueGT applies the GT predicate on the "resource_value" field.
func ResourceValueGT(v string) predicate.Resource {
	return predicate.Resource(sql.FieldGT(FieldResourceValue, v))
}

// ResourceValueGTE applies the GTE predicate on the "resource_value" field.
func ResourceValueGTE(v string) predicate.Resource {
	return predicate.Resource(sql.FieldGTE(FieldResourceValue, v))
}

// ResourceValueLT applies the LT predicate on the "resource_value" field.
func ResourceValueLT(v string) predicate.Resource {
	return predicate.Resource(sql.FieldLT(FieldResourceValue, v))
}

// ResourceValueLTE applies the LTE predicate on the "resource_value" field.
func ResourceValueLTE(v string) predicate.Resource {
	return predicate.Resource(sql.FieldLTE(FieldResourceValue, v))
}

// ResourceValueContains applies the Contains predicate on the "resource_value" field.
func ResourceValueContains(v string) predicate.Resource {
	return predicate.Resource(sql.FieldContains(FieldResourceValue, v))
}

// ResourceValueHasPrefix applies the HasPrefix predicate on the "resource_value" field.
func ResourceValueHasPrefix(v string) predicate.Resource {
	return predicate.Resource(sql.FieldHasPrefix(FieldResourceValue, v))
}

// ResourceValueHasSuffix applies the HasSuffix predicate on the "resource_value" field.
func ResourceValueHasSuffix(v string) predicate.Resource {
	return predicate.Resource(sql.FieldHasSuffix(FieldResourceValue, v))
}

// ResourceValueEqualFold applies the EqualFold predicate on the "resource_value" field.
func ResourceValueEqualFold(v string) predicate.Resource {
	return predicate.Resource(sql.FieldEqualFold(FieldResourceValue, v))
}

// ResourceValueContainsFold applies the ContainsFold predicate on the "resource_value" field.
func ResourceValueContainsFold(v string) predicate.Resource {
	return predicate.Resource(sql.FieldContainsFold(FieldResourceValue, v))
}

// HasRole applies the HasEdge predicate on the "role" edge.
func HasRole() predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, RoleTable, RolePrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasRoleWith applies the HasEdge predicate on the "role" edge with a given conditions (other predicates).
func HasRoleWith(preds ...predicate.Role) predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RoleInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, RoleTable, RolePrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUser applies the HasEdge predicate on the "user" edge.
func HasUser() predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, UserTable, UserPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserWith applies the HasEdge predicate on the "user" edge with a given conditions (other predicates).
func HasUserWith(preds ...predicate.User) predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, UserTable, UserPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAuthorization applies the HasEdge predicate on the "authorization" edge.
func HasAuthorization() predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AuthorizationTable, AuthorizationPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAuthorizationWith applies the HasEdge predicate on the "authorization" edge with a given conditions (other predicates).
func HasAuthorizationWith(preds ...predicate.Authorization) predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AuthorizationInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AuthorizationTable, AuthorizationPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Resource) predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Resource) predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Resource) predicate.Resource {
	return predicate.Resource(func(s *sql.Selector) {
		p(s.Not())
	})
}
