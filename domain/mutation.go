// Code generated by ent, DO NOT EDIT.

package domain

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/devcui/ncepu-cs-project/domain/authorization"
	"github.com/devcui/ncepu-cs-project/domain/campus"
	"github.com/devcui/ncepu-cs-project/domain/certificate"
	"github.com/devcui/ncepu-cs-project/domain/class"
	"github.com/devcui/ncepu-cs-project/domain/classleader"
	"github.com/devcui/ncepu-cs-project/domain/department"
	"github.com/devcui/ncepu-cs-project/domain/educationlevel"
	"github.com/devcui/ncepu-cs-project/domain/enrollmentstatus"
	"github.com/devcui/ncepu-cs-project/domain/familyinfo"
	"github.com/devcui/ncepu-cs-project/domain/major"
	"github.com/devcui/ncepu-cs-project/domain/majordirection"
	"github.com/devcui/ncepu-cs-project/domain/practicalexperience"
	"github.com/devcui/ncepu-cs-project/domain/predicate"
	"github.com/devcui/ncepu-cs-project/domain/resource"
	"github.com/devcui/ncepu-cs-project/domain/role"
	"github.com/devcui/ncepu-cs-project/domain/student"
	"github.com/devcui/ncepu-cs-project/domain/tutor"
	"github.com/devcui/ncepu-cs-project/domain/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthorization       = "Authorization"
	TypeCampus              = "Campus"
	TypeCertificate         = "Certificate"
	TypeClass               = "Class"
	TypeClassLeader         = "ClassLeader"
	TypeDepartment          = "Department"
	TypeEducationLevel      = "EducationLevel"
	TypeEnrollmentStatus    = "EnrollmentStatus"
	TypeFamilyInfo          = "FamilyInfo"
	TypeMajor               = "Major"
	TypeMajorDirection      = "MajorDirection"
	TypePracticalExperience = "PracticalExperience"
	TypeResource            = "Resource"
	TypeRole                = "Role"
	TypeStudent             = "Student"
	TypeTutor               = "Tutor"
	TypeUser                = "User"
)

// AuthorizationMutation represents an operation that mutates the Authorization nodes in the graph.
type AuthorizationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	client_id        *string
	client_secret    *string
	client_name      *string
	grant_type       *[]string
	appendgrant_type []string
	scope            *[]string
	appendscope      []string
	redirect_url     *string
	domain           *string
	clearedFields    map[string]struct{}
	resource         map[int]struct{}
	removedresource  map[int]struct{}
	clearedresource  bool
	done             bool
	oldValue         func(context.Context) (*Authorization, error)
	predicates       []predicate.Authorization
}

var _ ent.Mutation = (*AuthorizationMutation)(nil)

// authorizationOption allows management of the mutation configuration using functional options.
type authorizationOption func(*AuthorizationMutation)

// newAuthorizationMutation creates new mutation for the Authorization entity.
func newAuthorizationMutation(c config, op Op, opts ...authorizationOption) *AuthorizationMutation {
	m := &AuthorizationMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizationID sets the ID field of the mutation.
func withAuthorizationID(id int) authorizationOption {
	return func(m *AuthorizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Authorization
		)
		m.oldValue = func(ctx context.Context) (*Authorization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Authorization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorization sets the old Authorization of the mutation.
func withAuthorization(node *Authorization) authorizationOption {
	return func(m *AuthorizationMutation) {
		m.oldValue = func(context.Context) (*Authorization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Authorization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *AuthorizationMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthorizationMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthorizationMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *AuthorizationMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *AuthorizationMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *AuthorizationMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetClientName sets the "client_name" field.
func (m *AuthorizationMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *AuthorizationMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *AuthorizationMutation) ResetClientName() {
	m.client_name = nil
}

// SetGrantType sets the "grant_type" field.
func (m *AuthorizationMutation) SetGrantType(s []string) {
	m.grant_type = &s
	m.appendgrant_type = nil
}

// GrantType returns the value of the "grant_type" field in the mutation.
func (m *AuthorizationMutation) GrantType() (r []string, exists bool) {
	v := m.grant_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantType returns the old "grant_type" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldGrantType(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantType: %w", err)
	}
	return oldValue.GrantType, nil
}

// AppendGrantType adds s to the "grant_type" field.
func (m *AuthorizationMutation) AppendGrantType(s []string) {
	m.appendgrant_type = append(m.appendgrant_type, s...)
}

// AppendedGrantType returns the list of values that were appended to the "grant_type" field in this mutation.
func (m *AuthorizationMutation) AppendedGrantType() ([]string, bool) {
	if len(m.appendgrant_type) == 0 {
		return nil, false
	}
	return m.appendgrant_type, true
}

// ResetGrantType resets all changes to the "grant_type" field.
func (m *AuthorizationMutation) ResetGrantType() {
	m.grant_type = nil
	m.appendgrant_type = nil
}

// SetScope sets the "scope" field.
func (m *AuthorizationMutation) SetScope(s []string) {
	m.scope = &s
	m.appendscope = nil
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AuthorizationMutation) Scope() (r []string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldScope(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// AppendScope adds s to the "scope" field.
func (m *AuthorizationMutation) AppendScope(s []string) {
	m.appendscope = append(m.appendscope, s...)
}

// AppendedScope returns the list of values that were appended to the "scope" field in this mutation.
func (m *AuthorizationMutation) AppendedScope() ([]string, bool) {
	if len(m.appendscope) == 0 {
		return nil, false
	}
	return m.appendscope, true
}

// ResetScope resets all changes to the "scope" field.
func (m *AuthorizationMutation) ResetScope() {
	m.scope = nil
	m.appendscope = nil
}

// SetRedirectURL sets the "redirect_url" field.
func (m *AuthorizationMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *AuthorizationMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *AuthorizationMutation) ResetRedirectURL() {
	m.redirect_url = nil
}

// SetDomain sets the "domain" field.
func (m *AuthorizationMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *AuthorizationMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Authorization entity.
// If the Authorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *AuthorizationMutation) ResetDomain() {
	m.domain = nil
}

// AddResourceIDs adds the "resource" edge to the Resource entity by ids.
func (m *AuthorizationMutation) AddResourceIDs(ids ...int) {
	if m.resource == nil {
		m.resource = make(map[int]struct{})
	}
	for i := range ids {
		m.resource[ids[i]] = struct{}{}
	}
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *AuthorizationMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *AuthorizationMutation) ResourceCleared() bool {
	return m.clearedresource
}

// RemoveResourceIDs removes the "resource" edge to the Resource entity by IDs.
func (m *AuthorizationMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresource == nil {
		m.removedresource = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resource, ids[i])
		m.removedresource[ids[i]] = struct{}{}
	}
}

// RemovedResource returns the removed IDs of the "resource" edge to the Resource entity.
func (m *AuthorizationMutation) RemovedResourceIDs() (ids []int) {
	for id := range m.removedresource {
		ids = append(ids, id)
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
func (m *AuthorizationMutation) ResourceIDs() (ids []int) {
	for id := range m.resource {
		ids = append(ids, id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *AuthorizationMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
	m.removedresource = nil
}

// Where appends a list predicates to the AuthorizationMutation builder.
func (m *AuthorizationMutation) Where(ps ...predicate.Authorization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Authorization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Authorization).
func (m *AuthorizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.client_id != nil {
		fields = append(fields, authorization.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, authorization.FieldClientSecret)
	}
	if m.client_name != nil {
		fields = append(fields, authorization.FieldClientName)
	}
	if m.grant_type != nil {
		fields = append(fields, authorization.FieldGrantType)
	}
	if m.scope != nil {
		fields = append(fields, authorization.FieldScope)
	}
	if m.redirect_url != nil {
		fields = append(fields, authorization.FieldRedirectURL)
	}
	if m.domain != nil {
		fields = append(fields, authorization.FieldDomain)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorization.FieldClientID:
		return m.ClientID()
	case authorization.FieldClientSecret:
		return m.ClientSecret()
	case authorization.FieldClientName:
		return m.ClientName()
	case authorization.FieldGrantType:
		return m.GrantType()
	case authorization.FieldScope:
		return m.Scope()
	case authorization.FieldRedirectURL:
		return m.RedirectURL()
	case authorization.FieldDomain:
		return m.Domain()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorization.FieldClientID:
		return m.OldClientID(ctx)
	case authorization.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case authorization.FieldClientName:
		return m.OldClientName(ctx)
	case authorization.FieldGrantType:
		return m.OldGrantType(ctx)
	case authorization.FieldScope:
		return m.OldScope(ctx)
	case authorization.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case authorization.FieldDomain:
		return m.OldDomain(ctx)
	}
	return nil, fmt.Errorf("unknown Authorization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorization.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authorization.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case authorization.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case authorization.FieldGrantType:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantType(v)
		return nil
	case authorization.FieldScope:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case authorization.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case authorization.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	}
	return fmt.Errorf("unknown Authorization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Authorization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Authorization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizationMutation) ResetField(name string) error {
	switch name {
	case authorization.FieldClientID:
		m.ResetClientID()
		return nil
	case authorization.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case authorization.FieldClientName:
		m.ResetClientName()
		return nil
	case authorization.FieldGrantType:
		m.ResetGrantType()
		return nil
	case authorization.FieldScope:
		m.ResetScope()
		return nil
	case authorization.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case authorization.FieldDomain:
		m.ResetDomain()
		return nil
	}
	return fmt.Errorf("unknown Authorization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resource != nil {
		edges = append(edges, authorization.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authorization.EdgeResource:
		ids := make([]ent.Value, 0, len(m.resource))
		for id := range m.resource {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresource != nil {
		edges = append(edges, authorization.EdgeResource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authorization.EdgeResource:
		ids := make([]ent.Value, 0, len(m.removedresource))
		for id := range m.removedresource {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresource {
		edges = append(edges, authorization.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizationMutation) EdgeCleared(name string) bool {
	switch name {
	case authorization.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Authorization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizationMutation) ResetEdge(name string) error {
	switch name {
	case authorization.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Authorization edge %s", name)
}

// CampusMutation represents an operation that mutates the Campus nodes in the graph.
type CampusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	address       *string
	clearedFields map[string]struct{}
	class         *int
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*Campus, error)
	predicates    []predicate.Campus
}

var _ ent.Mutation = (*CampusMutation)(nil)

// campusOption allows management of the mutation configuration using functional options.
type campusOption func(*CampusMutation)

// newCampusMutation creates new mutation for the Campus entity.
func newCampusMutation(c config, op Op, opts ...campusOption) *CampusMutation {
	m := &CampusMutation{
		config:        c,
		op:            op,
		typ:           TypeCampus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampusID sets the ID field of the mutation.
func withCampusID(id int) campusOption {
	return func(m *CampusMutation) {
		var (
			err   error
			once  sync.Once
			value *Campus
		)
		m.oldValue = func(ctx context.Context) (*Campus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Campus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampus sets the old Campus of the mutation.
func withCampus(node *Campus) campusOption {
	return func(m *CampusMutation) {
		m.oldValue = func(context.Context) (*Campus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Campus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CampusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CampusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Campus entity.
// If the Campus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CampusMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *CampusMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CampusMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Campus entity.
// If the Campus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampusMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *CampusMutation) ResetAddress() {
	m.address = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *CampusMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *CampusMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *CampusMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *CampusMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *CampusMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *CampusMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the CampusMutation builder.
func (m *CampusMutation) Where(ps ...predicate.Campus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Campus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Campus).
func (m *CampusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampusMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, campus.FieldName)
	}
	if m.address != nil {
		fields = append(fields, campus.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campus.FieldName:
		return m.Name()
	case campus.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campus.FieldName:
		return m.OldName(ctx)
	case campus.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Campus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case campus.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Campus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Campus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Campus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampusMutation) ResetField(name string) error {
	switch name {
	case campus.FieldName:
		m.ResetName()
		return nil
	case campus.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown Campus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.class != nil {
		edges = append(edges, campus.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campus.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclass {
		edges = append(edges, campus.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampusMutation) EdgeCleared(name string) bool {
	switch name {
	case campus.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampusMutation) ClearEdge(name string) error {
	switch name {
	case campus.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Campus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampusMutation) ResetEdge(name string) error {
	switch name {
	case campus.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Campus edge %s", name)
}

// CertificateMutation represents an operation that mutates the Certificate nodes in the graph.
type CertificateMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	code              *string
	description       *string
	department        *string
	issue_date        *time.Time
	certificate_type  *string
	certificate_level *string
	certificate_type2 *string
	award_category    *string
	certificate_image *[]byte
	clearedFields     map[string]struct{}
	student           *int
	clearedstudent    bool
	done              bool
	oldValue          func(context.Context) (*Certificate, error)
	predicates        []predicate.Certificate
}

var _ ent.Mutation = (*CertificateMutation)(nil)

// certificateOption allows management of the mutation configuration using functional options.
type certificateOption func(*CertificateMutation)

// newCertificateMutation creates new mutation for the Certificate entity.
func newCertificateMutation(c config, op Op, opts ...certificateOption) *CertificateMutation {
	m := &CertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateID sets the ID field of the mutation.
func withCertificateID(id int) certificateOption {
	return func(m *CertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *Certificate
		)
		m.oldValue = func(ctx context.Context) (*Certificate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificate sets the old Certificate of the mutation.
func withCertificate(node *Certificate) certificateOption {
	return func(m *CertificateMutation) {
		m.oldValue = func(context.Context) (*Certificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certificate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CertificateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CertificateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CertificateMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CertificateMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CertificateMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CertificateMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *CertificateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CertificateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CertificateMutation) ResetDescription() {
	m.description = nil
}

// SetDepartment sets the "department" field.
func (m *CertificateMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *CertificateMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ResetDepartment resets all changes to the "department" field.
func (m *CertificateMutation) ResetDepartment() {
	m.department = nil
}

// SetIssueDate sets the "issue_date" field.
func (m *CertificateMutation) SetIssueDate(t time.Time) {
	m.issue_date = &t
}

// IssueDate returns the value of the "issue_date" field in the mutation.
func (m *CertificateMutation) IssueDate() (r time.Time, exists bool) {
	v := m.issue_date
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueDate returns the old "issue_date" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldIssueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueDate: %w", err)
	}
	return oldValue.IssueDate, nil
}

// ResetIssueDate resets all changes to the "issue_date" field.
func (m *CertificateMutation) ResetIssueDate() {
	m.issue_date = nil
}

// SetCertificateType sets the "certificate_type" field.
func (m *CertificateMutation) SetCertificateType(s string) {
	m.certificate_type = &s
}

// CertificateType returns the value of the "certificate_type" field in the mutation.
func (m *CertificateMutation) CertificateType() (r string, exists bool) {
	v := m.certificate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateType returns the old "certificate_type" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCertificateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateType: %w", err)
	}
	return oldValue.CertificateType, nil
}

// ResetCertificateType resets all changes to the "certificate_type" field.
func (m *CertificateMutation) ResetCertificateType() {
	m.certificate_type = nil
}

// SetCertificateLevel sets the "certificate_level" field.
func (m *CertificateMutation) SetCertificateLevel(s string) {
	m.certificate_level = &s
}

// CertificateLevel returns the value of the "certificate_level" field in the mutation.
func (m *CertificateMutation) CertificateLevel() (r string, exists bool) {
	v := m.certificate_level
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateLevel returns the old "certificate_level" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCertificateLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateLevel: %w", err)
	}
	return oldValue.CertificateLevel, nil
}

// ResetCertificateLevel resets all changes to the "certificate_level" field.
func (m *CertificateMutation) ResetCertificateLevel() {
	m.certificate_level = nil
}

// SetCertificateType2 sets the "certificate_type2" field.
func (m *CertificateMutation) SetCertificateType2(s string) {
	m.certificate_type2 = &s
}

// CertificateType2 returns the value of the "certificate_type2" field in the mutation.
func (m *CertificateMutation) CertificateType2() (r string, exists bool) {
	v := m.certificate_type2
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateType2 returns the old "certificate_type2" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCertificateType2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateType2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateType2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateType2: %w", err)
	}
	return oldValue.CertificateType2, nil
}

// ResetCertificateType2 resets all changes to the "certificate_type2" field.
func (m *CertificateMutation) ResetCertificateType2() {
	m.certificate_type2 = nil
}

// SetAwardCategory sets the "award_category" field.
func (m *CertificateMutation) SetAwardCategory(s string) {
	m.award_category = &s
}

// AwardCategory returns the value of the "award_category" field in the mutation.
func (m *CertificateMutation) AwardCategory() (r string, exists bool) {
	v := m.award_category
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardCategory returns the old "award_category" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldAwardCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardCategory: %w", err)
	}
	return oldValue.AwardCategory, nil
}

// ResetAwardCategory resets all changes to the "award_category" field.
func (m *CertificateMutation) ResetAwardCategory() {
	m.award_category = nil
}

// SetCertificateImage sets the "certificate_image" field.
func (m *CertificateMutation) SetCertificateImage(b []byte) {
	m.certificate_image = &b
}

// CertificateImage returns the value of the "certificate_image" field in the mutation.
func (m *CertificateMutation) CertificateImage() (r []byte, exists bool) {
	v := m.certificate_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateImage returns the old "certificate_image" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldCertificateImage(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateImage: %w", err)
	}
	return oldValue.CertificateImage, nil
}

// ResetCertificateImage resets all changes to the "certificate_image" field.
func (m *CertificateMutation) ResetCertificateImage() {
	m.certificate_image = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *CertificateMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *CertificateMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *CertificateMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *CertificateMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *CertificateMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *CertificateMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the CertificateMutation builder.
func (m *CertificateMutation) Where(ps ...predicate.Certificate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certificate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certificate).
func (m *CertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, certificate.FieldName)
	}
	if m.code != nil {
		fields = append(fields, certificate.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, certificate.FieldDescription)
	}
	if m.department != nil {
		fields = append(fields, certificate.FieldDepartment)
	}
	if m.issue_date != nil {
		fields = append(fields, certificate.FieldIssueDate)
	}
	if m.certificate_type != nil {
		fields = append(fields, certificate.FieldCertificateType)
	}
	if m.certificate_level != nil {
		fields = append(fields, certificate.FieldCertificateLevel)
	}
	if m.certificate_type2 != nil {
		fields = append(fields, certificate.FieldCertificateType2)
	}
	if m.award_category != nil {
		fields = append(fields, certificate.FieldAwardCategory)
	}
	if m.certificate_image != nil {
		fields = append(fields, certificate.FieldCertificateImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificate.FieldName:
		return m.Name()
	case certificate.FieldCode:
		return m.Code()
	case certificate.FieldDescription:
		return m.Description()
	case certificate.FieldDepartment:
		return m.Department()
	case certificate.FieldIssueDate:
		return m.IssueDate()
	case certificate.FieldCertificateType:
		return m.CertificateType()
	case certificate.FieldCertificateLevel:
		return m.CertificateLevel()
	case certificate.FieldCertificateType2:
		return m.CertificateType2()
	case certificate.FieldAwardCategory:
		return m.AwardCategory()
	case certificate.FieldCertificateImage:
		return m.CertificateImage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificate.FieldName:
		return m.OldName(ctx)
	case certificate.FieldCode:
		return m.OldCode(ctx)
	case certificate.FieldDescription:
		return m.OldDescription(ctx)
	case certificate.FieldDepartment:
		return m.OldDepartment(ctx)
	case certificate.FieldIssueDate:
		return m.OldIssueDate(ctx)
	case certificate.FieldCertificateType:
		return m.OldCertificateType(ctx)
	case certificate.FieldCertificateLevel:
		return m.OldCertificateLevel(ctx)
	case certificate.FieldCertificateType2:
		return m.OldCertificateType2(ctx)
	case certificate.FieldAwardCategory:
		return m.OldAwardCategory(ctx)
	case certificate.FieldCertificateImage:
		return m.OldCertificateImage(ctx)
	}
	return nil, fmt.Errorf("unknown Certificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case certificate.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case certificate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case certificate.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case certificate.FieldIssueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueDate(v)
		return nil
	case certificate.FieldCertificateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateType(v)
		return nil
	case certificate.FieldCertificateLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateLevel(v)
		return nil
	case certificate.FieldCertificateType2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateType2(v)
		return nil
	case certificate.FieldAwardCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardCategory(v)
		return nil
	case certificate.FieldCertificateImage:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateImage(v)
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Certificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateMutation) ResetField(name string) error {
	switch name {
	case certificate.FieldName:
		m.ResetName()
		return nil
	case certificate.FieldCode:
		m.ResetCode()
		return nil
	case certificate.FieldDescription:
		m.ResetDescription()
		return nil
	case certificate.FieldDepartment:
		m.ResetDepartment()
		return nil
	case certificate.FieldIssueDate:
		m.ResetIssueDate()
		return nil
	case certificate.FieldCertificateType:
		m.ResetCertificateType()
		return nil
	case certificate.FieldCertificateLevel:
		m.ResetCertificateLevel()
		return nil
	case certificate.FieldCertificateType2:
		m.ResetCertificateType2()
		return nil
	case certificate.FieldAwardCategory:
		m.ResetAwardCategory()
		return nil
	case certificate.FieldCertificateImage:
		m.ResetCertificateImage()
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.student != nil {
		edges = append(edges, certificate.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificate.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudent {
		edges = append(edges, certificate.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateMutation) EdgeCleared(name string) bool {
	switch name {
	case certificate.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateMutation) ClearEdge(name string) error {
	switch name {
	case certificate.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown Certificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateMutation) ResetEdge(name string) error {
	switch name {
	case certificate.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Certificate edge %s", name)
}

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	code                   *string
	description            *string
	_type                  *string
	clearedFields          map[string]struct{}
	major                  *int
	clearedmajor           bool
	department             *int
	cleareddepartment      bool
	campus                 *int
	clearedcampus          bool
	student                map[int]struct{}
	removedstudent         map[int]struct{}
	clearedstudent         bool
	class_leader           *int
	clearedclass_leader    bool
	tutor                  *int
	clearedtutor           bool
	major_direction        *int
	clearedmajor_direction bool
	done                   bool
	oldValue               func(context.Context) (*Class, error)
	predicates             []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id int) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *ClassMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ClassMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ClassMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ClassMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClassMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ClassMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *ClassMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ClassMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ClassMutation) ResetType() {
	m._type = nil
}

// SetMajorID sets the "major" edge to the Major entity by id.
func (m *ClassMutation) SetMajorID(id int) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the Major entity.
func (m *ClassMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the Major entity was cleared.
func (m *ClassMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *ClassMutation) MajorID() (id int, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *ClassMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *ClassMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *ClassMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *ClassMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *ClassMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *ClassMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetCampusID sets the "campus" edge to the Campus entity by id.
func (m *ClassMutation) SetCampusID(id int) {
	m.campus = &id
}

// ClearCampus clears the "campus" edge to the Campus entity.
func (m *ClassMutation) ClearCampus() {
	m.clearedcampus = true
}

// CampusCleared reports if the "campus" edge to the Campus entity was cleared.
func (m *ClassMutation) CampusCleared() bool {
	return m.clearedcampus
}

// CampusID returns the "campus" edge ID in the mutation.
func (m *ClassMutation) CampusID() (id int, exists bool) {
	if m.campus != nil {
		return *m.campus, true
	}
	return
}

// CampusIDs returns the "campus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampusID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) CampusIDs() (ids []int) {
	if id := m.campus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampus resets all changes to the "campus" edge.
func (m *ClassMutation) ResetCampus() {
	m.campus = nil
	m.clearedcampus = false
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *ClassMutation) AddStudentIDs(ids ...int) {
	if m.student == nil {
		m.student = make(map[int]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ClassMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ClassMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *ClassMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *ClassMutation) RemovedStudentIDs() (ids []int) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *ClassMutation) StudentIDs() (ids []int) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ClassMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// SetClassLeaderID sets the "class_leader" edge to the ClassLeader entity by id.
func (m *ClassMutation) SetClassLeaderID(id int) {
	m.class_leader = &id
}

// ClearClassLeader clears the "class_leader" edge to the ClassLeader entity.
func (m *ClassMutation) ClearClassLeader() {
	m.clearedclass_leader = true
}

// ClassLeaderCleared reports if the "class_leader" edge to the ClassLeader entity was cleared.
func (m *ClassMutation) ClassLeaderCleared() bool {
	return m.clearedclass_leader
}

// ClassLeaderID returns the "class_leader" edge ID in the mutation.
func (m *ClassMutation) ClassLeaderID() (id int, exists bool) {
	if m.class_leader != nil {
		return *m.class_leader, true
	}
	return
}

// ClassLeaderIDs returns the "class_leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassLeaderID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) ClassLeaderIDs() (ids []int) {
	if id := m.class_leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassLeader resets all changes to the "class_leader" edge.
func (m *ClassMutation) ResetClassLeader() {
	m.class_leader = nil
	m.clearedclass_leader = false
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *ClassMutation) SetTutorID(id int) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *ClassMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *ClassMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *ClassMutation) TutorID() (id int, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) TutorIDs() (ids []int) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *ClassMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// SetMajorDirectionID sets the "major_direction" edge to the MajorDirection entity by id.
func (m *ClassMutation) SetMajorDirectionID(id int) {
	m.major_direction = &id
}

// ClearMajorDirection clears the "major_direction" edge to the MajorDirection entity.
func (m *ClassMutation) ClearMajorDirection() {
	m.clearedmajor_direction = true
}

// MajorDirectionCleared reports if the "major_direction" edge to the MajorDirection entity was cleared.
func (m *ClassMutation) MajorDirectionCleared() bool {
	return m.clearedmajor_direction
}

// MajorDirectionID returns the "major_direction" edge ID in the mutation.
func (m *ClassMutation) MajorDirectionID() (id int, exists bool) {
	if m.major_direction != nil {
		return *m.major_direction, true
	}
	return
}

// MajorDirectionIDs returns the "major_direction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorDirectionID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) MajorDirectionIDs() (ids []int) {
	if id := m.major_direction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajorDirection resets all changes to the "major_direction" edge.
func (m *ClassMutation) ResetMajorDirection() {
	m.major_direction = nil
	m.clearedmajor_direction = false
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.code != nil {
		fields = append(fields, class.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, class.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, class.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldName:
		return m.Name()
	case class.FieldCode:
		return m.Code()
	case class.FieldDescription:
		return m.Description()
	case class.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldCode:
		return m.OldCode(ctx)
	case class.FieldDescription:
		return m.OldDescription(ctx)
	case class.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case class.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case class.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldCode:
		m.ResetCode()
		return nil
	case class.FieldDescription:
		m.ResetDescription()
		return nil
	case class.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.major != nil {
		edges = append(edges, class.EdgeMajor)
	}
	if m.department != nil {
		edges = append(edges, class.EdgeDepartment)
	}
	if m.campus != nil {
		edges = append(edges, class.EdgeCampus)
	}
	if m.student != nil {
		edges = append(edges, class.EdgeStudent)
	}
	if m.class_leader != nil {
		edges = append(edges, class.EdgeClassLeader)
	}
	if m.tutor != nil {
		edges = append(edges, class.EdgeTutor)
	}
	if m.major_direction != nil {
		edges = append(edges, class.EdgeMajorDirection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeCampus:
		if id := m.campus; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassLeader:
		if id := m.class_leader; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeMajorDirection:
		if id := m.major_direction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedstudent != nil {
		edges = append(edges, class.EdgeStudent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmajor {
		edges = append(edges, class.EdgeMajor)
	}
	if m.cleareddepartment {
		edges = append(edges, class.EdgeDepartment)
	}
	if m.clearedcampus {
		edges = append(edges, class.EdgeCampus)
	}
	if m.clearedstudent {
		edges = append(edges, class.EdgeStudent)
	}
	if m.clearedclass_leader {
		edges = append(edges, class.EdgeClassLeader)
	}
	if m.clearedtutor {
		edges = append(edges, class.EdgeTutor)
	}
	if m.clearedmajor_direction {
		edges = append(edges, class.EdgeMajorDirection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeMajor:
		return m.clearedmajor
	case class.EdgeDepartment:
		return m.cleareddepartment
	case class.EdgeCampus:
		return m.clearedcampus
	case class.EdgeStudent:
		return m.clearedstudent
	case class.EdgeClassLeader:
		return m.clearedclass_leader
	case class.EdgeTutor:
		return m.clearedtutor
	case class.EdgeMajorDirection:
		return m.clearedmajor_direction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeMajor:
		m.ClearMajor()
		return nil
	case class.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case class.EdgeCampus:
		m.ClearCampus()
		return nil
	case class.EdgeClassLeader:
		m.ClearClassLeader()
		return nil
	case class.EdgeTutor:
		m.ClearTutor()
		return nil
	case class.EdgeMajorDirection:
		m.ClearMajorDirection()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeMajor:
		m.ResetMajor()
		return nil
	case class.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case class.EdgeCampus:
		m.ResetCampus()
		return nil
	case class.EdgeStudent:
		m.ResetStudent()
		return nil
	case class.EdgeClassLeader:
		m.ResetClassLeader()
		return nil
	case class.EdgeTutor:
		m.ResetTutor()
		return nil
	case class.EdgeMajorDirection:
		m.ResetMajorDirection()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// ClassLeaderMutation represents an operation that mutates the ClassLeader nodes in the graph.
type ClassLeaderMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	class          *int
	clearedclass   bool
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*ClassLeader, error)
	predicates     []predicate.ClassLeader
}

var _ ent.Mutation = (*ClassLeaderMutation)(nil)

// classleaderOption allows management of the mutation configuration using functional options.
type classleaderOption func(*ClassLeaderMutation)

// newClassLeaderMutation creates new mutation for the ClassLeader entity.
func newClassLeaderMutation(c config, op Op, opts ...classleaderOption) *ClassLeaderMutation {
	m := &ClassLeaderMutation{
		config:        c,
		op:            op,
		typ:           TypeClassLeader,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassLeaderID sets the ID field of the mutation.
func withClassLeaderID(id int) classleaderOption {
	return func(m *ClassLeaderMutation) {
		var (
			err   error
			once  sync.Once
			value *ClassLeader
		)
		m.oldValue = func(ctx context.Context) (*ClassLeader, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClassLeader.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassLeader sets the old ClassLeader of the mutation.
func withClassLeader(node *ClassLeader) classleaderOption {
	return func(m *ClassLeaderMutation) {
		m.oldValue = func(context.Context) (*ClassLeader, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassLeaderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassLeaderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassLeaderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassLeaderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClassLeader.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *ClassLeaderMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ClassLeaderMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ClassLeaderMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *ClassLeaderMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ClassLeaderMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ClassLeaderMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *ClassLeaderMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ClassLeaderMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ClassLeaderMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *ClassLeaderMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *ClassLeaderMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ClassLeaderMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the ClassLeaderMutation builder.
func (m *ClassLeaderMutation) Where(ps ...predicate.ClassLeader) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassLeaderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassLeaderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClassLeader, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassLeaderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassLeaderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClassLeader).
func (m *ClassLeaderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassLeaderMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassLeaderMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassLeaderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ClassLeader field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassLeaderMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClassLeader field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassLeaderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassLeaderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassLeaderMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ClassLeader numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassLeaderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassLeaderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassLeaderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClassLeader nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassLeaderMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ClassLeader field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassLeaderMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, classleader.EdgeClass)
	}
	if m.student != nil {
		edges = append(edges, classleader.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassLeaderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classleader.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case classleader.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassLeaderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassLeaderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassLeaderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, classleader.EdgeClass)
	}
	if m.clearedstudent {
		edges = append(edges, classleader.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassLeaderMutation) EdgeCleared(name string) bool {
	switch name {
	case classleader.EdgeClass:
		return m.clearedclass
	case classleader.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassLeaderMutation) ClearEdge(name string) error {
	switch name {
	case classleader.EdgeClass:
		m.ClearClass()
		return nil
	case classleader.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown ClassLeader unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassLeaderMutation) ResetEdge(name string) error {
	switch name {
	case classleader.EdgeClass:
		m.ResetClass()
		return nil
	case classleader.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown ClassLeader edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	code           *string
	description    *string
	clearedFields  map[string]struct{}
	major          map[int]struct{}
	removedmajor   map[int]struct{}
	clearedmajor   bool
	class          map[int]struct{}
	removedclass   map[int]struct{}
	clearedclass   bool
	student        map[int]struct{}
	removedstudent map[int]struct{}
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*Department, error)
	predicates     []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *DepartmentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DepartmentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DepartmentMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
}

// AddMajorIDs adds the "major" edge to the Major entity by ids.
func (m *DepartmentMutation) AddMajorIDs(ids ...int) {
	if m.major == nil {
		m.major = make(map[int]struct{})
	}
	for i := range ids {
		m.major[ids[i]] = struct{}{}
	}
}

// ClearMajor clears the "major" edge to the Major entity.
func (m *DepartmentMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the Major entity was cleared.
func (m *DepartmentMutation) MajorCleared() bool {
	return m.clearedmajor
}

// RemoveMajorIDs removes the "major" edge to the Major entity by IDs.
func (m *DepartmentMutation) RemoveMajorIDs(ids ...int) {
	if m.removedmajor == nil {
		m.removedmajor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.major, ids[i])
		m.removedmajor[ids[i]] = struct{}{}
	}
}

// RemovedMajor returns the removed IDs of the "major" edge to the Major entity.
func (m *DepartmentMutation) RemovedMajorIDs() (ids []int) {
	for id := range m.removedmajor {
		ids = append(ids, id)
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
func (m *DepartmentMutation) MajorIDs() (ids []int) {
	for id := range m.major {
		ids = append(ids, id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *DepartmentMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
	m.removedmajor = nil
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *DepartmentMutation) AddClasIDs(ids ...int) {
	if m.class == nil {
		m.class = make(map[int]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *DepartmentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *DepartmentMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *DepartmentMutation) RemoveClasIDs(ids ...int) {
	if m.removedclass == nil {
		m.removedclass = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *DepartmentMutation) RemovedClassIDs() (ids []int) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *DepartmentMutation) ClassIDs() (ids []int) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *DepartmentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *DepartmentMutation) AddStudentIDs(ids ...int) {
	if m.student == nil {
		m.student = make(map[int]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *DepartmentMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *DepartmentMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *DepartmentMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *DepartmentMutation) RemovedStudentIDs() (ids []int) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *DepartmentMutation) StudentIDs() (ids []int) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *DepartmentMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.code != nil {
		fields = append(fields, department.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldCode:
		return m.Code()
	case department.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldCode:
		return m.OldCode(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldCode:
		m.ResetCode()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.major != nil {
		edges = append(edges, department.EdgeMajor)
	}
	if m.class != nil {
		edges = append(edges, department.EdgeClass)
	}
	if m.student != nil {
		edges = append(edges, department.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeMajor:
		ids := make([]ent.Value, 0, len(m.major))
		for id := range m.major {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmajor != nil {
		edges = append(edges, department.EdgeMajor)
	}
	if m.removedclass != nil {
		edges = append(edges, department.EdgeClass)
	}
	if m.removedstudent != nil {
		edges = append(edges, department.EdgeStudent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeMajor:
		ids := make([]ent.Value, 0, len(m.removedmajor))
		for id := range m.removedmajor {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmajor {
		edges = append(edges, department.EdgeMajor)
	}
	if m.clearedclass {
		edges = append(edges, department.EdgeClass)
	}
	if m.clearedstudent {
		edges = append(edges, department.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeMajor:
		return m.clearedmajor
	case department.EdgeClass:
		return m.clearedclass
	case department.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeMajor:
		m.ResetMajor()
		return nil
	case department.EdgeClass:
		m.ResetClass()
		return nil
	case department.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// EducationLevelMutation represents an operation that mutates the EducationLevel nodes in the graph.
type EducationLevelMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*EducationLevel, error)
	predicates     []predicate.EducationLevel
}

var _ ent.Mutation = (*EducationLevelMutation)(nil)

// educationlevelOption allows management of the mutation configuration using functional options.
type educationlevelOption func(*EducationLevelMutation)

// newEducationLevelMutation creates new mutation for the EducationLevel entity.
func newEducationLevelMutation(c config, op Op, opts ...educationlevelOption) *EducationLevelMutation {
	m := &EducationLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationLevelID sets the ID field of the mutation.
func withEducationLevelID(id int) educationlevelOption {
	return func(m *EducationLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *EducationLevel
		)
		m.oldValue = func(ctx context.Context) (*EducationLevel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EducationLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationLevel sets the old EducationLevel of the mutation.
func withEducationLevel(node *EducationLevel) educationlevelOption {
	return func(m *EducationLevelMutation) {
		m.oldValue = func(context.Context) (*EducationLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationLevelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EducationLevel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EducationLevelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EducationLevelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EducationLevel entity.
// If the EducationLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationLevelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EducationLevelMutation) ResetName() {
	m.name = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *EducationLevelMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *EducationLevelMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *EducationLevelMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *EducationLevelMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *EducationLevelMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *EducationLevelMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the EducationLevelMutation builder.
func (m *EducationLevelMutation) Where(ps ...predicate.EducationLevel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationLevelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationLevelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EducationLevel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationLevelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationLevelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EducationLevel).
func (m *EducationLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationLevelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, educationlevel.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationlevel.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationlevel.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EducationLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationlevel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EducationLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationLevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationLevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EducationLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationLevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationLevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EducationLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationLevelMutation) ResetField(name string) error {
	switch name {
	case educationlevel.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EducationLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.student != nil {
		edges = append(edges, educationlevel.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationLevelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudent {
		edges = append(edges, educationlevel.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case educationlevel.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationLevelMutation) ClearEdge(name string) error {
	switch name {
	case educationlevel.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown EducationLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationLevelMutation) ResetEdge(name string) error {
	switch name {
	case educationlevel.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown EducationLevel edge %s", name)
}

// EnrollmentStatusMutation represents an operation that mutates the EnrollmentStatus nodes in the graph.
type EnrollmentStatusMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*EnrollmentStatus, error)
	predicates     []predicate.EnrollmentStatus
}

var _ ent.Mutation = (*EnrollmentStatusMutation)(nil)

// enrollmentstatusOption allows management of the mutation configuration using functional options.
type enrollmentstatusOption func(*EnrollmentStatusMutation)

// newEnrollmentStatusMutation creates new mutation for the EnrollmentStatus entity.
func newEnrollmentStatusMutation(c config, op Op, opts ...enrollmentstatusOption) *EnrollmentStatusMutation {
	m := &EnrollmentStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeEnrollmentStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnrollmentStatusID sets the ID field of the mutation.
func withEnrollmentStatusID(id int) enrollmentstatusOption {
	return func(m *EnrollmentStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *EnrollmentStatus
		)
		m.oldValue = func(ctx context.Context) (*EnrollmentStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnrollmentStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnrollmentStatus sets the old EnrollmentStatus of the mutation.
func withEnrollmentStatus(node *EnrollmentStatus) enrollmentstatusOption {
	return func(m *EnrollmentStatusMutation) {
		m.oldValue = func(context.Context) (*EnrollmentStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnrollmentStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnrollmentStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnrollmentStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnrollmentStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnrollmentStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EnrollmentStatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnrollmentStatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EnrollmentStatus entity.
// If the EnrollmentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnrollmentStatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnrollmentStatusMutation) ResetName() {
	m.name = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *EnrollmentStatusMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *EnrollmentStatusMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *EnrollmentStatusMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *EnrollmentStatusMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *EnrollmentStatusMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *EnrollmentStatusMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the EnrollmentStatusMutation builder.
func (m *EnrollmentStatusMutation) Where(ps ...predicate.EnrollmentStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnrollmentStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnrollmentStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnrollmentStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnrollmentStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnrollmentStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnrollmentStatus).
func (m *EnrollmentStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnrollmentStatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, enrollmentstatus.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnrollmentStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enrollmentstatus.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnrollmentStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enrollmentstatus.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EnrollmentStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnrollmentStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enrollmentstatus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EnrollmentStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnrollmentStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnrollmentStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnrollmentStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnrollmentStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnrollmentStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnrollmentStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnrollmentStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnrollmentStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnrollmentStatusMutation) ResetField(name string) error {
	switch name {
	case enrollmentstatus.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EnrollmentStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnrollmentStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.student != nil {
		edges = append(edges, enrollmentstatus.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnrollmentStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enrollmentstatus.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnrollmentStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnrollmentStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnrollmentStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudent {
		edges = append(edges, enrollmentstatus.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnrollmentStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case enrollmentstatus.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnrollmentStatusMutation) ClearEdge(name string) error {
	switch name {
	case enrollmentstatus.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown EnrollmentStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnrollmentStatusMutation) ResetEdge(name string) error {
	switch name {
	case enrollmentstatus.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown EnrollmentStatus edge %s", name)
}

// FamilyInfoMutation represents an operation that mutates the FamilyInfo nodes in the graph.
type FamilyInfoMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	relationship   *string
	id_card        *string
	age            *string
	occupation     *string
	post           *string
	work_unit      *string
	contact_number *string
	health         *string
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*FamilyInfo, error)
	predicates     []predicate.FamilyInfo
}

var _ ent.Mutation = (*FamilyInfoMutation)(nil)

// familyinfoOption allows management of the mutation configuration using functional options.
type familyinfoOption func(*FamilyInfoMutation)

// newFamilyInfoMutation creates new mutation for the FamilyInfo entity.
func newFamilyInfoMutation(c config, op Op, opts ...familyinfoOption) *FamilyInfoMutation {
	m := &FamilyInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFamilyInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFamilyInfoID sets the ID field of the mutation.
func withFamilyInfoID(id int) familyinfoOption {
	return func(m *FamilyInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FamilyInfo
		)
		m.oldValue = func(ctx context.Context) (*FamilyInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FamilyInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFamilyInfo sets the old FamilyInfo of the mutation.
func withFamilyInfo(node *FamilyInfo) familyinfoOption {
	return func(m *FamilyInfoMutation) {
		m.oldValue = func(context.Context) (*FamilyInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FamilyInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FamilyInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FamilyInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FamilyInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FamilyInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FamilyInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FamilyInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FamilyInfoMutation) ResetName() {
	m.name = nil
}

// SetRelationship sets the "relationship" field.
func (m *FamilyInfoMutation) SetRelationship(s string) {
	m.relationship = &s
}

// Relationship returns the value of the "relationship" field in the mutation.
func (m *FamilyInfoMutation) Relationship() (r string, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationship returns the old "relationship" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldRelationship(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationship is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationship: %w", err)
	}
	return oldValue.Relationship, nil
}

// ResetRelationship resets all changes to the "relationship" field.
func (m *FamilyInfoMutation) ResetRelationship() {
	m.relationship = nil
}

// SetIDCard sets the "id_card" field.
func (m *FamilyInfoMutation) SetIDCard(s string) {
	m.id_card = &s
}

// IDCard returns the value of the "id_card" field in the mutation.
func (m *FamilyInfoMutation) IDCard() (r string, exists bool) {
	v := m.id_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCard returns the old "id_card" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldIDCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCard: %w", err)
	}
	return oldValue.IDCard, nil
}

// ResetIDCard resets all changes to the "id_card" field.
func (m *FamilyInfoMutation) ResetIDCard() {
	m.id_card = nil
}

// SetAge sets the "age" field.
func (m *FamilyInfoMutation) SetAge(s string) {
	m.age = &s
}

// Age returns the value of the "age" field in the mutation.
func (m *FamilyInfoMutation) Age() (r string, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// ResetAge resets all changes to the "age" field.
func (m *FamilyInfoMutation) ResetAge() {
	m.age = nil
}

// SetOccupation sets the "occupation" field.
func (m *FamilyInfoMutation) SetOccupation(s string) {
	m.occupation = &s
}

// Occupation returns the value of the "occupation" field in the mutation.
func (m *FamilyInfoMutation) Occupation() (r string, exists bool) {
	v := m.occupation
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupation returns the old "occupation" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldOccupation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccupation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccupation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupation: %w", err)
	}
	return oldValue.Occupation, nil
}

// ResetOccupation resets all changes to the "occupation" field.
func (m *FamilyInfoMutation) ResetOccupation() {
	m.occupation = nil
}

// SetPost sets the "post" field.
func (m *FamilyInfoMutation) SetPost(s string) {
	m.post = &s
}

// Post returns the value of the "post" field in the mutation.
func (m *FamilyInfoMutation) Post() (r string, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPost returns the old "post" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldPost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPost: %w", err)
	}
	return oldValue.Post, nil
}

// ResetPost resets all changes to the "post" field.
func (m *FamilyInfoMutation) ResetPost() {
	m.post = nil
}

// SetWorkUnit sets the "work_unit" field.
func (m *FamilyInfoMutation) SetWorkUnit(s string) {
	m.work_unit = &s
}

// WorkUnit returns the value of the "work_unit" field in the mutation.
func (m *FamilyInfoMutation) WorkUnit() (r string, exists bool) {
	v := m.work_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkUnit returns the old "work_unit" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldWorkUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkUnit: %w", err)
	}
	return oldValue.WorkUnit, nil
}

// ResetWorkUnit resets all changes to the "work_unit" field.
func (m *FamilyInfoMutation) ResetWorkUnit() {
	m.work_unit = nil
}

// SetContactNumber sets the "contact_number" field.
func (m *FamilyInfoMutation) SetContactNumber(s string) {
	m.contact_number = &s
}

// ContactNumber returns the value of the "contact_number" field in the mutation.
func (m *FamilyInfoMutation) ContactNumber() (r string, exists bool) {
	v := m.contact_number
	if v == nil {
		return
	}
	return *v, true
}

// OldContactNumber returns the old "contact_number" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldContactNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactNumber: %w", err)
	}
	return oldValue.ContactNumber, nil
}

// ResetContactNumber resets all changes to the "contact_number" field.
func (m *FamilyInfoMutation) ResetContactNumber() {
	m.contact_number = nil
}

// SetHealth sets the "health" field.
func (m *FamilyInfoMutation) SetHealth(s string) {
	m.health = &s
}

// Health returns the value of the "health" field in the mutation.
func (m *FamilyInfoMutation) Health() (r string, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old "health" field's value of the FamilyInfo entity.
// If the FamilyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FamilyInfoMutation) OldHealth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// ResetHealth resets all changes to the "health" field.
func (m *FamilyInfoMutation) ResetHealth() {
	m.health = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *FamilyInfoMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *FamilyInfoMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *FamilyInfoMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *FamilyInfoMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *FamilyInfoMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *FamilyInfoMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the FamilyInfoMutation builder.
func (m *FamilyInfoMutation) Where(ps ...predicate.FamilyInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FamilyInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FamilyInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FamilyInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FamilyInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FamilyInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FamilyInfo).
func (m *FamilyInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FamilyInfoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, familyinfo.FieldName)
	}
	if m.relationship != nil {
		fields = append(fields, familyinfo.FieldRelationship)
	}
	if m.id_card != nil {
		fields = append(fields, familyinfo.FieldIDCard)
	}
	if m.age != nil {
		fields = append(fields, familyinfo.FieldAge)
	}
	if m.occupation != nil {
		fields = append(fields, familyinfo.FieldOccupation)
	}
	if m.post != nil {
		fields = append(fields, familyinfo.FieldPost)
	}
	if m.work_unit != nil {
		fields = append(fields, familyinfo.FieldWorkUnit)
	}
	if m.contact_number != nil {
		fields = append(fields, familyinfo.FieldContactNumber)
	}
	if m.health != nil {
		fields = append(fields, familyinfo.FieldHealth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FamilyInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case familyinfo.FieldName:
		return m.Name()
	case familyinfo.FieldRelationship:
		return m.Relationship()
	case familyinfo.FieldIDCard:
		return m.IDCard()
	case familyinfo.FieldAge:
		return m.Age()
	case familyinfo.FieldOccupation:
		return m.Occupation()
	case familyinfo.FieldPost:
		return m.Post()
	case familyinfo.FieldWorkUnit:
		return m.WorkUnit()
	case familyinfo.FieldContactNumber:
		return m.ContactNumber()
	case familyinfo.FieldHealth:
		return m.Health()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FamilyInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case familyinfo.FieldName:
		return m.OldName(ctx)
	case familyinfo.FieldRelationship:
		return m.OldRelationship(ctx)
	case familyinfo.FieldIDCard:
		return m.OldIDCard(ctx)
	case familyinfo.FieldAge:
		return m.OldAge(ctx)
	case familyinfo.FieldOccupation:
		return m.OldOccupation(ctx)
	case familyinfo.FieldPost:
		return m.OldPost(ctx)
	case familyinfo.FieldWorkUnit:
		return m.OldWorkUnit(ctx)
	case familyinfo.FieldContactNumber:
		return m.OldContactNumber(ctx)
	case familyinfo.FieldHealth:
		return m.OldHealth(ctx)
	}
	return nil, fmt.Errorf("unknown FamilyInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FamilyInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case familyinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case familyinfo.FieldRelationship:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationship(v)
		return nil
	case familyinfo.FieldIDCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCard(v)
		return nil
	case familyinfo.FieldAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case familyinfo.FieldOccupation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupation(v)
		return nil
	case familyinfo.FieldPost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPost(v)
		return nil
	case familyinfo.FieldWorkUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkUnit(v)
		return nil
	case familyinfo.FieldContactNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactNumber(v)
		return nil
	case familyinfo.FieldHealth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	}
	return fmt.Errorf("unknown FamilyInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FamilyInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FamilyInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FamilyInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FamilyInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FamilyInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FamilyInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FamilyInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FamilyInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FamilyInfoMutation) ResetField(name string) error {
	switch name {
	case familyinfo.FieldName:
		m.ResetName()
		return nil
	case familyinfo.FieldRelationship:
		m.ResetRelationship()
		return nil
	case familyinfo.FieldIDCard:
		m.ResetIDCard()
		return nil
	case familyinfo.FieldAge:
		m.ResetAge()
		return nil
	case familyinfo.FieldOccupation:
		m.ResetOccupation()
		return nil
	case familyinfo.FieldPost:
		m.ResetPost()
		return nil
	case familyinfo.FieldWorkUnit:
		m.ResetWorkUnit()
		return nil
	case familyinfo.FieldContactNumber:
		m.ResetContactNumber()
		return nil
	case familyinfo.FieldHealth:
		m.ResetHealth()
		return nil
	}
	return fmt.Errorf("unknown FamilyInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FamilyInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.student != nil {
		edges = append(edges, familyinfo.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FamilyInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case familyinfo.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FamilyInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FamilyInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FamilyInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudent {
		edges = append(edges, familyinfo.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FamilyInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case familyinfo.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FamilyInfoMutation) ClearEdge(name string) error {
	switch name {
	case familyinfo.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown FamilyInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FamilyInfoMutation) ResetEdge(name string) error {
	switch name {
	case familyinfo.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown FamilyInfo edge %s", name)
}

// MajorMutation represents an operation that mutates the Major nodes in the graph.
type MajorMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	code              *string
	description       *string
	special_type      *string
	enrollment_type   *string
	is_major_category *bool
	major_category    *string
	clearedFields     map[string]struct{}
	department        *int
	cleareddepartment bool
	student           map[int]struct{}
	removedstudent    map[int]struct{}
	clearedstudent    bool
	class             map[int]struct{}
	removedclass      map[int]struct{}
	clearedclass      bool
	done              bool
	oldValue          func(context.Context) (*Major, error)
	predicates        []predicate.Major
}

var _ ent.Mutation = (*MajorMutation)(nil)

// majorOption allows management of the mutation configuration using functional options.
type majorOption func(*MajorMutation)

// newMajorMutation creates new mutation for the Major entity.
func newMajorMutation(c config, op Op, opts ...majorOption) *MajorMutation {
	m := &MajorMutation{
		config:        c,
		op:            op,
		typ:           TypeMajor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMajorID sets the ID field of the mutation.
func withMajorID(id int) majorOption {
	return func(m *MajorMutation) {
		var (
			err   error
			once  sync.Once
			value *Major
		)
		m.oldValue = func(ctx context.Context) (*Major, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Major.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMajor sets the old Major of the mutation.
func withMajor(node *Major) majorOption {
	return func(m *MajorMutation) {
		m.oldValue = func(context.Context) (*Major, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MajorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MajorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MajorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MajorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Major.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MajorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MajorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MajorMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *MajorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *MajorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *MajorMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *MajorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MajorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MajorMutation) ResetDescription() {
	m.description = nil
}

// SetSpecialType sets the "special_type" field.
func (m *MajorMutation) SetSpecialType(s string) {
	m.special_type = &s
}

// SpecialType returns the value of the "special_type" field in the mutation.
func (m *MajorMutation) SpecialType() (r string, exists bool) {
	v := m.special_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialType returns the old "special_type" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldSpecialType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialType: %w", err)
	}
	return oldValue.SpecialType, nil
}

// ResetSpecialType resets all changes to the "special_type" field.
func (m *MajorMutation) ResetSpecialType() {
	m.special_type = nil
}

// SetEnrollmentType sets the "enrollment_type" field.
func (m *MajorMutation) SetEnrollmentType(s string) {
	m.enrollment_type = &s
}

// EnrollmentType returns the value of the "enrollment_type" field in the mutation.
func (m *MajorMutation) EnrollmentType() (r string, exists bool) {
	v := m.enrollment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEnrollmentType returns the old "enrollment_type" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldEnrollmentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnrollmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnrollmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnrollmentType: %w", err)
	}
	return oldValue.EnrollmentType, nil
}

// ResetEnrollmentType resets all changes to the "enrollment_type" field.
func (m *MajorMutation) ResetEnrollmentType() {
	m.enrollment_type = nil
}

// SetIsMajorCategory sets the "is_major_category" field.
func (m *MajorMutation) SetIsMajorCategory(b bool) {
	m.is_major_category = &b
}

// IsMajorCategory returns the value of the "is_major_category" field in the mutation.
func (m *MajorMutation) IsMajorCategory() (r bool, exists bool) {
	v := m.is_major_category
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMajorCategory returns the old "is_major_category" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldIsMajorCategory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMajorCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMajorCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMajorCategory: %w", err)
	}
	return oldValue.IsMajorCategory, nil
}

// ResetIsMajorCategory resets all changes to the "is_major_category" field.
func (m *MajorMutation) ResetIsMajorCategory() {
	m.is_major_category = nil
}

// SetMajorCategory sets the "major_category" field.
func (m *MajorMutation) SetMajorCategory(s string) {
	m.major_category = &s
}

// MajorCategory returns the value of the "major_category" field in the mutation.
func (m *MajorMutation) MajorCategory() (r string, exists bool) {
	v := m.major_category
	if v == nil {
		return
	}
	return *v, true
}

// OldMajorCategory returns the old "major_category" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldMajorCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMajorCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMajorCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajorCategory: %w", err)
	}
	return oldValue.MajorCategory, nil
}

// ResetMajorCategory resets all changes to the "major_category" field.
func (m *MajorMutation) ResetMajorCategory() {
	m.major_category = nil
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *MajorMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *MajorMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *MajorMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *MajorMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *MajorMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *MajorMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *MajorMutation) AddStudentIDs(ids ...int) {
	if m.student == nil {
		m.student = make(map[int]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *MajorMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *MajorMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *MajorMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *MajorMutation) RemovedStudentIDs() (ids []int) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *MajorMutation) StudentIDs() (ids []int) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *MajorMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *MajorMutation) AddClasIDs(ids ...int) {
	if m.class == nil {
		m.class = make(map[int]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *MajorMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *MajorMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *MajorMutation) RemoveClasIDs(ids ...int) {
	if m.removedclass == nil {
		m.removedclass = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *MajorMutation) RemovedClassIDs() (ids []int) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *MajorMutation) ClassIDs() (ids []int) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *MajorMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// Where appends a list predicates to the MajorMutation builder.
func (m *MajorMutation) Where(ps ...predicate.Major) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MajorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MajorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Major, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MajorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MajorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Major).
func (m *MajorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MajorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, major.FieldName)
	}
	if m.code != nil {
		fields = append(fields, major.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, major.FieldDescription)
	}
	if m.special_type != nil {
		fields = append(fields, major.FieldSpecialType)
	}
	if m.enrollment_type != nil {
		fields = append(fields, major.FieldEnrollmentType)
	}
	if m.is_major_category != nil {
		fields = append(fields, major.FieldIsMajorCategory)
	}
	if m.major_category != nil {
		fields = append(fields, major.FieldMajorCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MajorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case major.FieldName:
		return m.Name()
	case major.FieldCode:
		return m.Code()
	case major.FieldDescription:
		return m.Description()
	case major.FieldSpecialType:
		return m.SpecialType()
	case major.FieldEnrollmentType:
		return m.EnrollmentType()
	case major.FieldIsMajorCategory:
		return m.IsMajorCategory()
	case major.FieldMajorCategory:
		return m.MajorCategory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MajorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case major.FieldName:
		return m.OldName(ctx)
	case major.FieldCode:
		return m.OldCode(ctx)
	case major.FieldDescription:
		return m.OldDescription(ctx)
	case major.FieldSpecialType:
		return m.OldSpecialType(ctx)
	case major.FieldEnrollmentType:
		return m.OldEnrollmentType(ctx)
	case major.FieldIsMajorCategory:
		return m.OldIsMajorCategory(ctx)
	case major.FieldMajorCategory:
		return m.OldMajorCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Major field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case major.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case major.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case major.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case major.FieldSpecialType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialType(v)
		return nil
	case major.FieldEnrollmentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnrollmentType(v)
		return nil
	case major.FieldIsMajorCategory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMajorCategory(v)
		return nil
	case major.FieldMajorCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajorCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Major field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MajorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MajorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Major numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MajorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MajorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MajorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Major nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MajorMutation) ResetField(name string) error {
	switch name {
	case major.FieldName:
		m.ResetName()
		return nil
	case major.FieldCode:
		m.ResetCode()
		return nil
	case major.FieldDescription:
		m.ResetDescription()
		return nil
	case major.FieldSpecialType:
		m.ResetSpecialType()
		return nil
	case major.FieldEnrollmentType:
		m.ResetEnrollmentType()
		return nil
	case major.FieldIsMajorCategory:
		m.ResetIsMajorCategory()
		return nil
	case major.FieldMajorCategory:
		m.ResetMajorCategory()
		return nil
	}
	return fmt.Errorf("unknown Major field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MajorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.department != nil {
		edges = append(edges, major.EdgeDepartment)
	}
	if m.student != nil {
		edges = append(edges, major.EdgeStudent)
	}
	if m.class != nil {
		edges = append(edges, major.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MajorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case major.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case major.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	case major.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MajorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstudent != nil {
		edges = append(edges, major.EdgeStudent)
	}
	if m.removedclass != nil {
		edges = append(edges, major.EdgeClass)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MajorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case major.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	case major.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MajorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddepartment {
		edges = append(edges, major.EdgeDepartment)
	}
	if m.clearedstudent {
		edges = append(edges, major.EdgeStudent)
	}
	if m.clearedclass {
		edges = append(edges, major.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MajorMutation) EdgeCleared(name string) bool {
	switch name {
	case major.EdgeDepartment:
		return m.cleareddepartment
	case major.EdgeStudent:
		return m.clearedstudent
	case major.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MajorMutation) ClearEdge(name string) error {
	switch name {
	case major.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Major unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MajorMutation) ResetEdge(name string) error {
	switch name {
	case major.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case major.EdgeStudent:
		m.ResetStudent()
		return nil
	case major.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Major edge %s", name)
}

// MajorDirectionMutation represents an operation that mutates the MajorDirection nodes in the graph.
type MajorDirectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	class         *int
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*MajorDirection, error)
	predicates    []predicate.MajorDirection
}

var _ ent.Mutation = (*MajorDirectionMutation)(nil)

// majordirectionOption allows management of the mutation configuration using functional options.
type majordirectionOption func(*MajorDirectionMutation)

// newMajorDirectionMutation creates new mutation for the MajorDirection entity.
func newMajorDirectionMutation(c config, op Op, opts ...majordirectionOption) *MajorDirectionMutation {
	m := &MajorDirectionMutation{
		config:        c,
		op:            op,
		typ:           TypeMajorDirection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMajorDirectionID sets the ID field of the mutation.
func withMajorDirectionID(id int) majordirectionOption {
	return func(m *MajorDirectionMutation) {
		var (
			err   error
			once  sync.Once
			value *MajorDirection
		)
		m.oldValue = func(ctx context.Context) (*MajorDirection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MajorDirection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMajorDirection sets the old MajorDirection of the mutation.
func withMajorDirection(node *MajorDirection) majordirectionOption {
	return func(m *MajorDirectionMutation) {
		m.oldValue = func(context.Context) (*MajorDirection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MajorDirectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MajorDirectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MajorDirectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MajorDirectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MajorDirection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MajorDirectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MajorDirectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MajorDirection entity.
// If the MajorDirection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDirectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MajorDirectionMutation) ResetName() {
	m.name = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *MajorDirectionMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *MajorDirectionMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *MajorDirectionMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *MajorDirectionMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *MajorDirectionMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *MajorDirectionMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the MajorDirectionMutation builder.
func (m *MajorDirectionMutation) Where(ps ...predicate.MajorDirection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MajorDirectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MajorDirectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MajorDirection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MajorDirectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MajorDirectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MajorDirection).
func (m *MajorDirectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MajorDirectionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, majordirection.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MajorDirectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case majordirection.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MajorDirectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case majordirection.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MajorDirection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorDirectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case majordirection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MajorDirection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MajorDirectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MajorDirectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorDirectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MajorDirection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MajorDirectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MajorDirectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MajorDirectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MajorDirection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MajorDirectionMutation) ResetField(name string) error {
	switch name {
	case majordirection.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MajorDirection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MajorDirectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.class != nil {
		edges = append(edges, majordirection.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MajorDirectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case majordirection.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MajorDirectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MajorDirectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MajorDirectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclass {
		edges = append(edges, majordirection.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MajorDirectionMutation) EdgeCleared(name string) bool {
	switch name {
	case majordirection.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MajorDirectionMutation) ClearEdge(name string) error {
	switch name {
	case majordirection.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown MajorDirection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MajorDirectionMutation) ResetEdge(name string) error {
	switch name {
	case majordirection.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown MajorDirection edge %s", name)
}

// PracticalExperienceMutation represents an operation that mutates the PracticalExperience nodes in the graph.
type PracticalExperienceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	unit           *string
	start_time     *time.Time
	end_time       *time.Time
	describe       *string
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*PracticalExperience, error)
	predicates     []predicate.PracticalExperience
}

var _ ent.Mutation = (*PracticalExperienceMutation)(nil)

// practicalexperienceOption allows management of the mutation configuration using functional options.
type practicalexperienceOption func(*PracticalExperienceMutation)

// newPracticalExperienceMutation creates new mutation for the PracticalExperience entity.
func newPracticalExperienceMutation(c config, op Op, opts ...practicalexperienceOption) *PracticalExperienceMutation {
	m := &PracticalExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypePracticalExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPracticalExperienceID sets the ID field of the mutation.
func withPracticalExperienceID(id int) practicalexperienceOption {
	return func(m *PracticalExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *PracticalExperience
		)
		m.oldValue = func(ctx context.Context) (*PracticalExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PracticalExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPracticalExperience sets the old PracticalExperience of the mutation.
func withPracticalExperience(node *PracticalExperience) practicalexperienceOption {
	return func(m *PracticalExperienceMutation) {
		m.oldValue = func(context.Context) (*PracticalExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PracticalExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PracticalExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PracticalExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PracticalExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PracticalExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PracticalExperienceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PracticalExperienceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PracticalExperience entity.
// If the PracticalExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticalExperienceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PracticalExperienceMutation) ResetName() {
	m.name = nil
}

// SetUnit sets the "unit" field.
func (m *PracticalExperienceMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *PracticalExperienceMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the PracticalExperience entity.
// If the PracticalExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticalExperienceMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *PracticalExperienceMutation) ResetUnit() {
	m.unit = nil
}

// SetStartTime sets the "start_time" field.
func (m *PracticalExperienceMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *PracticalExperienceMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the PracticalExperience entity.
// If the PracticalExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticalExperienceMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *PracticalExperienceMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *PracticalExperienceMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *PracticalExperienceMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the PracticalExperience entity.
// If the PracticalExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticalExperienceMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *PracticalExperienceMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDescribe sets the "describe" field.
func (m *PracticalExperienceMutation) SetDescribe(s string) {
	m.describe = &s
}

// Describe returns the value of the "describe" field in the mutation.
func (m *PracticalExperienceMutation) Describe() (r string, exists bool) {
	v := m.describe
	if v == nil {
		return
	}
	return *v, true
}

// OldDescribe returns the old "describe" field's value of the PracticalExperience entity.
// If the PracticalExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticalExperienceMutation) OldDescribe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescribe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescribe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescribe: %w", err)
	}
	return oldValue.Describe, nil
}

// ResetDescribe resets all changes to the "describe" field.
func (m *PracticalExperienceMutation) ResetDescribe() {
	m.describe = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *PracticalExperienceMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *PracticalExperienceMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *PracticalExperienceMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *PracticalExperienceMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *PracticalExperienceMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *PracticalExperienceMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the PracticalExperienceMutation builder.
func (m *PracticalExperienceMutation) Where(ps ...predicate.PracticalExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PracticalExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PracticalExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PracticalExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PracticalExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PracticalExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PracticalExperience).
func (m *PracticalExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PracticalExperienceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, practicalexperience.FieldName)
	}
	if m.unit != nil {
		fields = append(fields, practicalexperience.FieldUnit)
	}
	if m.start_time != nil {
		fields = append(fields, practicalexperience.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, practicalexperience.FieldEndTime)
	}
	if m.describe != nil {
		fields = append(fields, practicalexperience.FieldDescribe)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PracticalExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case practicalexperience.FieldName:
		return m.Name()
	case practicalexperience.FieldUnit:
		return m.Unit()
	case practicalexperience.FieldStartTime:
		return m.StartTime()
	case practicalexperience.FieldEndTime:
		return m.EndTime()
	case practicalexperience.FieldDescribe:
		return m.Describe()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PracticalExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case practicalexperience.FieldName:
		return m.OldName(ctx)
	case practicalexperience.FieldUnit:
		return m.OldUnit(ctx)
	case practicalexperience.FieldStartTime:
		return m.OldStartTime(ctx)
	case practicalexperience.FieldEndTime:
		return m.OldEndTime(ctx)
	case practicalexperience.FieldDescribe:
		return m.OldDescribe(ctx)
	}
	return nil, fmt.Errorf("unknown PracticalExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PracticalExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case practicalexperience.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case practicalexperience.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case practicalexperience.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case practicalexperience.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case practicalexperience.FieldDescribe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescribe(v)
		return nil
	}
	return fmt.Errorf("unknown PracticalExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PracticalExperienceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PracticalExperienceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PracticalExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PracticalExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PracticalExperienceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PracticalExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PracticalExperienceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PracticalExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PracticalExperienceMutation) ResetField(name string) error {
	switch name {
	case practicalexperience.FieldName:
		m.ResetName()
		return nil
	case practicalexperience.FieldUnit:
		m.ResetUnit()
		return nil
	case practicalexperience.FieldStartTime:
		m.ResetStartTime()
		return nil
	case practicalexperience.FieldEndTime:
		m.ResetEndTime()
		return nil
	case practicalexperience.FieldDescribe:
		m.ResetDescribe()
		return nil
	}
	return fmt.Errorf("unknown PracticalExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PracticalExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.student != nil {
		edges = append(edges, practicalexperience.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PracticalExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case practicalexperience.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PracticalExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PracticalExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PracticalExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstudent {
		edges = append(edges, practicalexperience.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PracticalExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case practicalexperience.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PracticalExperienceMutation) ClearEdge(name string) error {
	switch name {
	case practicalexperience.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown PracticalExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PracticalExperienceMutation) ResetEdge(name string) error {
	switch name {
	case practicalexperience.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown PracticalExperience edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	resource_name        *string
	resource_value       *string
	clearedFields        map[string]struct{}
	role                 map[int]struct{}
	removedrole          map[int]struct{}
	clearedrole          bool
	user                 map[int]struct{}
	removeduser          map[int]struct{}
	cleareduser          bool
	authorization        map[int]struct{}
	removedauthorization map[int]struct{}
	clearedauthorization bool
	done                 bool
	oldValue             func(context.Context) (*Resource, error)
	predicates           []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResourceName sets the "resource_name" field.
func (m *ResourceMutation) SetResourceName(s string) {
	m.resource_name = &s
}

// ResourceName returns the value of the "resource_name" field in the mutation.
func (m *ResourceMutation) ResourceName() (r string, exists bool) {
	v := m.resource_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceName returns the old "resource_name" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldResourceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceName: %w", err)
	}
	return oldValue.ResourceName, nil
}

// ResetResourceName resets all changes to the "resource_name" field.
func (m *ResourceMutation) ResetResourceName() {
	m.resource_name = nil
}

// SetResourceValue sets the "resource_value" field.
func (m *ResourceMutation) SetResourceValue(s string) {
	m.resource_value = &s
}

// ResourceValue returns the value of the "resource_value" field in the mutation.
func (m *ResourceMutation) ResourceValue() (r string, exists bool) {
	v := m.resource_value
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceValue returns the old "resource_value" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldResourceValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceValue: %w", err)
	}
	return oldValue.ResourceValue, nil
}

// ResetResourceValue resets all changes to the "resource_value" field.
func (m *ResourceMutation) ResetResourceValue() {
	m.resource_value = nil
}

// AddRoleIDs adds the "role" edge to the Role entity by ids.
func (m *ResourceMutation) AddRoleIDs(ids ...int) {
	if m.role == nil {
		m.role = make(map[int]struct{})
	}
	for i := range ids {
		m.role[ids[i]] = struct{}{}
	}
}

// ClearRole clears the "role" edge to the Role entity.
func (m *ResourceMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *ResourceMutation) RoleCleared() bool {
	return m.clearedrole
}

// RemoveRoleIDs removes the "role" edge to the Role entity by IDs.
func (m *ResourceMutation) RemoveRoleIDs(ids ...int) {
	if m.removedrole == nil {
		m.removedrole = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role, ids[i])
		m.removedrole[ids[i]] = struct{}{}
	}
}

// RemovedRole returns the removed IDs of the "role" edge to the Role entity.
func (m *ResourceMutation) RemovedRoleIDs() (ids []int) {
	for id := range m.removedrole {
		ids = append(ids, id)
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
func (m *ResourceMutation) RoleIDs() (ids []int) {
	for id := range m.role {
		ids = append(ids, id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *ResourceMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
	m.removedrole = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *ResourceMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *ResourceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ResourceMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *ResourceMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *ResourceMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *ResourceMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ResourceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddAuthorizationIDs adds the "authorization" edge to the Authorization entity by ids.
func (m *ResourceMutation) AddAuthorizationIDs(ids ...int) {
	if m.authorization == nil {
		m.authorization = make(map[int]struct{})
	}
	for i := range ids {
		m.authorization[ids[i]] = struct{}{}
	}
}

// ClearAuthorization clears the "authorization" edge to the Authorization entity.
func (m *ResourceMutation) ClearAuthorization() {
	m.clearedauthorization = true
}

// AuthorizationCleared reports if the "authorization" edge to the Authorization entity was cleared.
func (m *ResourceMutation) AuthorizationCleared() bool {
	return m.clearedauthorization
}

// RemoveAuthorizationIDs removes the "authorization" edge to the Authorization entity by IDs.
func (m *ResourceMutation) RemoveAuthorizationIDs(ids ...int) {
	if m.removedauthorization == nil {
		m.removedauthorization = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authorization, ids[i])
		m.removedauthorization[ids[i]] = struct{}{}
	}
}

// RemovedAuthorization returns the removed IDs of the "authorization" edge to the Authorization entity.
func (m *ResourceMutation) RemovedAuthorizationIDs() (ids []int) {
	for id := range m.removedauthorization {
		ids = append(ids, id)
	}
	return
}

// AuthorizationIDs returns the "authorization" edge IDs in the mutation.
func (m *ResourceMutation) AuthorizationIDs() (ids []int) {
	for id := range m.authorization {
		ids = append(ids, id)
	}
	return
}

// ResetAuthorization resets all changes to the "authorization" edge.
func (m *ResourceMutation) ResetAuthorization() {
	m.authorization = nil
	m.clearedauthorization = false
	m.removedauthorization = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.resource_name != nil {
		fields = append(fields, resource.FieldResourceName)
	}
	if m.resource_value != nil {
		fields = append(fields, resource.FieldResourceValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldResourceName:
		return m.ResourceName()
	case resource.FieldResourceValue:
		return m.ResourceValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldResourceName:
		return m.OldResourceName(ctx)
	case resource.FieldResourceValue:
		return m.OldResourceValue(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldResourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceName(v)
		return nil
	case resource.FieldResourceValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceValue(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldResourceName:
		m.ResetResourceName()
		return nil
	case resource.FieldResourceValue:
		m.ResetResourceValue()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.role != nil {
		edges = append(edges, resource.EdgeRole)
	}
	if m.user != nil {
		edges = append(edges, resource.EdgeUser)
	}
	if m.authorization != nil {
		edges = append(edges, resource.EdgeAuthorization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeRole:
		ids := make([]ent.Value, 0, len(m.role))
		for id := range m.role {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeAuthorization:
		ids := make([]ent.Value, 0, len(m.authorization))
		for id := range m.authorization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrole != nil {
		edges = append(edges, resource.EdgeRole)
	}
	if m.removeduser != nil {
		edges = append(edges, resource.EdgeUser)
	}
	if m.removedauthorization != nil {
		edges = append(edges, resource.EdgeAuthorization)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeRole:
		ids := make([]ent.Value, 0, len(m.removedrole))
		for id := range m.removedrole {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeAuthorization:
		ids := make([]ent.Value, 0, len(m.removedauthorization))
		for id := range m.removedauthorization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrole {
		edges = append(edges, resource.EdgeRole)
	}
	if m.cleareduser {
		edges = append(edges, resource.EdgeUser)
	}
	if m.clearedauthorization {
		edges = append(edges, resource.EdgeAuthorization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeRole:
		return m.clearedrole
	case resource.EdgeUser:
		return m.cleareduser
	case resource.EdgeAuthorization:
		return m.clearedauthorization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeRole:
		m.ResetRole()
		return nil
	case resource.EdgeUser:
		m.ResetUser()
		return nil
	case resource.EdgeAuthorization:
		m.ResetAuthorization()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op              Op
	typ             string
	id              *int
	role_name       *string
	role_value      *string
	clearedFields   map[string]struct{}
	resource        map[int]struct{}
	removedresource map[int]struct{}
	clearedresource bool
	user            map[int]struct{}
	removeduser     map[int]struct{}
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Role, error)
	predicates      []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleName sets the "role_name" field.
func (m *RoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *RoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *RoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetRoleValue sets the "role_value" field.
func (m *RoleMutation) SetRoleValue(s string) {
	m.role_value = &s
}

// RoleValue returns the value of the "role_value" field in the mutation.
func (m *RoleMutation) RoleValue() (r string, exists bool) {
	v := m.role_value
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleValue returns the old "role_value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleValue: %w", err)
	}
	return oldValue.RoleValue, nil
}

// ResetRoleValue resets all changes to the "role_value" field.
func (m *RoleMutation) ResetRoleValue() {
	m.role_value = nil
}

// AddResourceIDs adds the "resource" edge to the Resource entity by ids.
func (m *RoleMutation) AddResourceIDs(ids ...int) {
	if m.resource == nil {
		m.resource = make(map[int]struct{})
	}
	for i := range ids {
		m.resource[ids[i]] = struct{}{}
	}
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *RoleMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *RoleMutation) ResourceCleared() bool {
	return m.clearedresource
}

// RemoveResourceIDs removes the "resource" edge to the Resource entity by IDs.
func (m *RoleMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresource == nil {
		m.removedresource = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resource, ids[i])
		m.removedresource[ids[i]] = struct{}{}
	}
}

// RemovedResource returns the removed IDs of the "resource" edge to the Resource entity.
func (m *RoleMutation) RemovedResourceIDs() (ids []int) {
	for id := range m.removedresource {
		ids = append(ids, id)
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
func (m *RoleMutation) ResourceIDs() (ids []int) {
	for id := range m.resource {
		ids = append(ids, id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *RoleMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
	m.removedresource = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *RoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RoleMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *RoleMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *RoleMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role_name != nil {
		fields = append(fields, role.FieldRoleName)
	}
	if m.role_value != nil {
		fields = append(fields, role.FieldRoleValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldRoleName:
		return m.RoleName()
	case role.FieldRoleValue:
		return m.RoleValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldRoleName:
		return m.OldRoleName(ctx)
	case role.FieldRoleValue:
		return m.OldRoleValue(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case role.FieldRoleValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleValue(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldRoleName:
		m.ResetRoleName()
		return nil
	case role.FieldRoleValue:
		m.ResetRoleValue()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.resource != nil {
		edges = append(edges, role.EdgeResource)
	}
	if m.user != nil {
		edges = append(edges, role.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeResource:
		ids := make([]ent.Value, 0, len(m.resource))
		for id := range m.resource {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedresource != nil {
		edges = append(edges, role.EdgeResource)
	}
	if m.removeduser != nil {
		edges = append(edges, role.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeResource:
		ids := make([]ent.Value, 0, len(m.removedresource))
		for id := range m.removedresource {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresource {
		edges = append(edges, role.EdgeResource)
	}
	if m.cleareduser {
		edges = append(edges, role.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeResource:
		return m.clearedresource
	case role.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeResource:
		m.ResetResource()
		return nil
	case role.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	clearedFields               map[string]struct{}
	user                        *int
	cleareduser                 bool
	department                  *int
	cleareddepartment           bool
	major                       *int
	clearedmajor                bool
	class                       *int
	clearedclass                bool
	class_leader                *int
	clearedclass_leader         bool
	tutor                       *int
	clearedtutor                bool
	certificate                 map[int]struct{}
	removedcertificate          map[int]struct{}
	clearedcertificate          bool
	education_level             map[int]struct{}
	removededucation_level      map[int]struct{}
	clearededucation_level      bool
	enrollment_status           map[int]struct{}
	removedenrollment_status    map[int]struct{}
	clearedenrollment_status    bool
	family_info                 map[int]struct{}
	removedfamily_info          map[int]struct{}
	clearedfamily_info          bool
	practical_experience        map[int]struct{}
	removedpractical_experience map[int]struct{}
	clearedpractical_experience bool
	done                        bool
	oldValue                    func(context.Context) (*Student, error)
	predicates                  []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id int) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *StudentMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *StudentMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *StudentMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *StudentMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *StudentMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetMajorID sets the "major" edge to the Major entity by id.
func (m *StudentMutation) SetMajorID(id int) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the Major entity.
func (m *StudentMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the Major entity was cleared.
func (m *StudentMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *StudentMutation) MajorID() (id int, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *StudentMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *StudentMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *StudentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *StudentMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *StudentMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *StudentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetClassLeaderID sets the "class_leader" edge to the ClassLeader entity by id.
func (m *StudentMutation) SetClassLeaderID(id int) {
	m.class_leader = &id
}

// ClearClassLeader clears the "class_leader" edge to the ClassLeader entity.
func (m *StudentMutation) ClearClassLeader() {
	m.clearedclass_leader = true
}

// ClassLeaderCleared reports if the "class_leader" edge to the ClassLeader entity was cleared.
func (m *StudentMutation) ClassLeaderCleared() bool {
	return m.clearedclass_leader
}

// ClassLeaderID returns the "class_leader" edge ID in the mutation.
func (m *StudentMutation) ClassLeaderID() (id int, exists bool) {
	if m.class_leader != nil {
		return *m.class_leader, true
	}
	return
}

// ClassLeaderIDs returns the "class_leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassLeaderID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) ClassLeaderIDs() (ids []int) {
	if id := m.class_leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassLeader resets all changes to the "class_leader" edge.
func (m *StudentMutation) ResetClassLeader() {
	m.class_leader = nil
	m.clearedclass_leader = false
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *StudentMutation) SetTutorID(id int) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *StudentMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *StudentMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *StudentMutation) TutorID() (id int, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) TutorIDs() (ids []int) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *StudentMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// AddCertificateIDs adds the "certificate" edge to the Certificate entity by ids.
func (m *StudentMutation) AddCertificateIDs(ids ...int) {
	if m.certificate == nil {
		m.certificate = make(map[int]struct{})
	}
	for i := range ids {
		m.certificate[ids[i]] = struct{}{}
	}
}

// ClearCertificate clears the "certificate" edge to the Certificate entity.
func (m *StudentMutation) ClearCertificate() {
	m.clearedcertificate = true
}

// CertificateCleared reports if the "certificate" edge to the Certificate entity was cleared.
func (m *StudentMutation) CertificateCleared() bool {
	return m.clearedcertificate
}

// RemoveCertificateIDs removes the "certificate" edge to the Certificate entity by IDs.
func (m *StudentMutation) RemoveCertificateIDs(ids ...int) {
	if m.removedcertificate == nil {
		m.removedcertificate = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.certificate, ids[i])
		m.removedcertificate[ids[i]] = struct{}{}
	}
}

// RemovedCertificate returns the removed IDs of the "certificate" edge to the Certificate entity.
func (m *StudentMutation) RemovedCertificateIDs() (ids []int) {
	for id := range m.removedcertificate {
		ids = append(ids, id)
	}
	return
}

// CertificateIDs returns the "certificate" edge IDs in the mutation.
func (m *StudentMutation) CertificateIDs() (ids []int) {
	for id := range m.certificate {
		ids = append(ids, id)
	}
	return
}

// ResetCertificate resets all changes to the "certificate" edge.
func (m *StudentMutation) ResetCertificate() {
	m.certificate = nil
	m.clearedcertificate = false
	m.removedcertificate = nil
}

// AddEducationLevelIDs adds the "education_level" edge to the EducationLevel entity by ids.
func (m *StudentMutation) AddEducationLevelIDs(ids ...int) {
	if m.education_level == nil {
		m.education_level = make(map[int]struct{})
	}
	for i := range ids {
		m.education_level[ids[i]] = struct{}{}
	}
}

// ClearEducationLevel clears the "education_level" edge to the EducationLevel entity.
func (m *StudentMutation) ClearEducationLevel() {
	m.clearededucation_level = true
}

// EducationLevelCleared reports if the "education_level" edge to the EducationLevel entity was cleared.
func (m *StudentMutation) EducationLevelCleared() bool {
	return m.clearededucation_level
}

// RemoveEducationLevelIDs removes the "education_level" edge to the EducationLevel entity by IDs.
func (m *StudentMutation) RemoveEducationLevelIDs(ids ...int) {
	if m.removededucation_level == nil {
		m.removededucation_level = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.education_level, ids[i])
		m.removededucation_level[ids[i]] = struct{}{}
	}
}

// RemovedEducationLevel returns the removed IDs of the "education_level" edge to the EducationLevel entity.
func (m *StudentMutation) RemovedEducationLevelIDs() (ids []int) {
	for id := range m.removededucation_level {
		ids = append(ids, id)
	}
	return
}

// EducationLevelIDs returns the "education_level" edge IDs in the mutation.
func (m *StudentMutation) EducationLevelIDs() (ids []int) {
	for id := range m.education_level {
		ids = append(ids, id)
	}
	return
}

// ResetEducationLevel resets all changes to the "education_level" edge.
func (m *StudentMutation) ResetEducationLevel() {
	m.education_level = nil
	m.clearededucation_level = false
	m.removededucation_level = nil
}

// AddEnrollmentStatuIDs adds the "enrollment_status" edge to the EnrollmentStatus entity by ids.
func (m *StudentMutation) AddEnrollmentStatuIDs(ids ...int) {
	if m.enrollment_status == nil {
		m.enrollment_status = make(map[int]struct{})
	}
	for i := range ids {
		m.enrollment_status[ids[i]] = struct{}{}
	}
}

// ClearEnrollmentStatus clears the "enrollment_status" edge to the EnrollmentStatus entity.
func (m *StudentMutation) ClearEnrollmentStatus() {
	m.clearedenrollment_status = true
}

// EnrollmentStatusCleared reports if the "enrollment_status" edge to the EnrollmentStatus entity was cleared.
func (m *StudentMutation) EnrollmentStatusCleared() bool {
	return m.clearedenrollment_status
}

// RemoveEnrollmentStatuIDs removes the "enrollment_status" edge to the EnrollmentStatus entity by IDs.
func (m *StudentMutation) RemoveEnrollmentStatuIDs(ids ...int) {
	if m.removedenrollment_status == nil {
		m.removedenrollment_status = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.enrollment_status, ids[i])
		m.removedenrollment_status[ids[i]] = struct{}{}
	}
}

// RemovedEnrollmentStatus returns the removed IDs of the "enrollment_status" edge to the EnrollmentStatus entity.
func (m *StudentMutation) RemovedEnrollmentStatusIDs() (ids []int) {
	for id := range m.removedenrollment_status {
		ids = append(ids, id)
	}
	return
}

// EnrollmentStatusIDs returns the "enrollment_status" edge IDs in the mutation.
func (m *StudentMutation) EnrollmentStatusIDs() (ids []int) {
	for id := range m.enrollment_status {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollmentStatus resets all changes to the "enrollment_status" edge.
func (m *StudentMutation) ResetEnrollmentStatus() {
	m.enrollment_status = nil
	m.clearedenrollment_status = false
	m.removedenrollment_status = nil
}

// AddFamilyInfoIDs adds the "family_info" edge to the FamilyInfo entity by ids.
func (m *StudentMutation) AddFamilyInfoIDs(ids ...int) {
	if m.family_info == nil {
		m.family_info = make(map[int]struct{})
	}
	for i := range ids {
		m.family_info[ids[i]] = struct{}{}
	}
}

// ClearFamilyInfo clears the "family_info" edge to the FamilyInfo entity.
func (m *StudentMutation) ClearFamilyInfo() {
	m.clearedfamily_info = true
}

// FamilyInfoCleared reports if the "family_info" edge to the FamilyInfo entity was cleared.
func (m *StudentMutation) FamilyInfoCleared() bool {
	return m.clearedfamily_info
}

// RemoveFamilyInfoIDs removes the "family_info" edge to the FamilyInfo entity by IDs.
func (m *StudentMutation) RemoveFamilyInfoIDs(ids ...int) {
	if m.removedfamily_info == nil {
		m.removedfamily_info = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.family_info, ids[i])
		m.removedfamily_info[ids[i]] = struct{}{}
	}
}

// RemovedFamilyInfo returns the removed IDs of the "family_info" edge to the FamilyInfo entity.
func (m *StudentMutation) RemovedFamilyInfoIDs() (ids []int) {
	for id := range m.removedfamily_info {
		ids = append(ids, id)
	}
	return
}

// FamilyInfoIDs returns the "family_info" edge IDs in the mutation.
func (m *StudentMutation) FamilyInfoIDs() (ids []int) {
	for id := range m.family_info {
		ids = append(ids, id)
	}
	return
}

// ResetFamilyInfo resets all changes to the "family_info" edge.
func (m *StudentMutation) ResetFamilyInfo() {
	m.family_info = nil
	m.clearedfamily_info = false
	m.removedfamily_info = nil
}

// AddPracticalExperienceIDs adds the "practical_experience" edge to the PracticalExperience entity by ids.
func (m *StudentMutation) AddPracticalExperienceIDs(ids ...int) {
	if m.practical_experience == nil {
		m.practical_experience = make(map[int]struct{})
	}
	for i := range ids {
		m.practical_experience[ids[i]] = struct{}{}
	}
}

// ClearPracticalExperience clears the "practical_experience" edge to the PracticalExperience entity.
func (m *StudentMutation) ClearPracticalExperience() {
	m.clearedpractical_experience = true
}

// PracticalExperienceCleared reports if the "practical_experience" edge to the PracticalExperience entity was cleared.
func (m *StudentMutation) PracticalExperienceCleared() bool {
	return m.clearedpractical_experience
}

// RemovePracticalExperienceIDs removes the "practical_experience" edge to the PracticalExperience entity by IDs.
func (m *StudentMutation) RemovePracticalExperienceIDs(ids ...int) {
	if m.removedpractical_experience == nil {
		m.removedpractical_experience = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.practical_experience, ids[i])
		m.removedpractical_experience[ids[i]] = struct{}{}
	}
}

// RemovedPracticalExperience returns the removed IDs of the "practical_experience" edge to the PracticalExperience entity.
func (m *StudentMutation) RemovedPracticalExperienceIDs() (ids []int) {
	for id := range m.removedpractical_experience {
		ids = append(ids, id)
	}
	return
}

// PracticalExperienceIDs returns the "practical_experience" edge IDs in the mutation.
func (m *StudentMutation) PracticalExperienceIDs() (ids []int) {
	for id := range m.practical_experience {
		ids = append(ids, id)
	}
	return
}

// ResetPracticalExperience resets all changes to the "practical_experience" edge.
func (m *StudentMutation) ResetPracticalExperience() {
	m.practical_experience = nil
	m.clearedpractical_experience = false
	m.removedpractical_experience = nil
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	if m.department != nil {
		edges = append(edges, student.EdgeDepartment)
	}
	if m.major != nil {
		edges = append(edges, student.EdgeMajor)
	}
	if m.class != nil {
		edges = append(edges, student.EdgeClass)
	}
	if m.class_leader != nil {
		edges = append(edges, student.EdgeClassLeader)
	}
	if m.tutor != nil {
		edges = append(edges, student.EdgeTutor)
	}
	if m.certificate != nil {
		edges = append(edges, student.EdgeCertificate)
	}
	if m.education_level != nil {
		edges = append(edges, student.EdgeEducationLevel)
	}
	if m.enrollment_status != nil {
		edges = append(edges, student.EdgeEnrollmentStatus)
	}
	if m.family_info != nil {
		edges = append(edges, student.EdgeFamilyInfo)
	}
	if m.practical_experience != nil {
		edges = append(edges, student.EdgePracticalExperience)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeClassLeader:
		if id := m.class_leader; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeCertificate:
		ids := make([]ent.Value, 0, len(m.certificate))
		for id := range m.certificate {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeEducationLevel:
		ids := make([]ent.Value, 0, len(m.education_level))
		for id := range m.education_level {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeEnrollmentStatus:
		ids := make([]ent.Value, 0, len(m.enrollment_status))
		for id := range m.enrollment_status {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeFamilyInfo:
		ids := make([]ent.Value, 0, len(m.family_info))
		for id := range m.family_info {
			ids = append(ids, id)
		}
		return ids
	case student.EdgePracticalExperience:
		ids := make([]ent.Value, 0, len(m.practical_experience))
		for id := range m.practical_experience {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedcertificate != nil {
		edges = append(edges, student.EdgeCertificate)
	}
	if m.removededucation_level != nil {
		edges = append(edges, student.EdgeEducationLevel)
	}
	if m.removedenrollment_status != nil {
		edges = append(edges, student.EdgeEnrollmentStatus)
	}
	if m.removedfamily_info != nil {
		edges = append(edges, student.EdgeFamilyInfo)
	}
	if m.removedpractical_experience != nil {
		edges = append(edges, student.EdgePracticalExperience)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeCertificate:
		ids := make([]ent.Value, 0, len(m.removedcertificate))
		for id := range m.removedcertificate {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeEducationLevel:
		ids := make([]ent.Value, 0, len(m.removededucation_level))
		for id := range m.removededucation_level {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeEnrollmentStatus:
		ids := make([]ent.Value, 0, len(m.removedenrollment_status))
		for id := range m.removedenrollment_status {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeFamilyInfo:
		ids := make([]ent.Value, 0, len(m.removedfamily_info))
		for id := range m.removedfamily_info {
			ids = append(ids, id)
		}
		return ids
	case student.EdgePracticalExperience:
		ids := make([]ent.Value, 0, len(m.removedpractical_experience))
		for id := range m.removedpractical_experience {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	if m.cleareddepartment {
		edges = append(edges, student.EdgeDepartment)
	}
	if m.clearedmajor {
		edges = append(edges, student.EdgeMajor)
	}
	if m.clearedclass {
		edges = append(edges, student.EdgeClass)
	}
	if m.clearedclass_leader {
		edges = append(edges, student.EdgeClassLeader)
	}
	if m.clearedtutor {
		edges = append(edges, student.EdgeTutor)
	}
	if m.clearedcertificate {
		edges = append(edges, student.EdgeCertificate)
	}
	if m.clearededucation_level {
		edges = append(edges, student.EdgeEducationLevel)
	}
	if m.clearedenrollment_status {
		edges = append(edges, student.EdgeEnrollmentStatus)
	}
	if m.clearedfamily_info {
		edges = append(edges, student.EdgeFamilyInfo)
	}
	if m.clearedpractical_experience {
		edges = append(edges, student.EdgePracticalExperience)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeUser:
		return m.cleareduser
	case student.EdgeDepartment:
		return m.cleareddepartment
	case student.EdgeMajor:
		return m.clearedmajor
	case student.EdgeClass:
		return m.clearedclass
	case student.EdgeClassLeader:
		return m.clearedclass_leader
	case student.EdgeTutor:
		return m.clearedtutor
	case student.EdgeCertificate:
		return m.clearedcertificate
	case student.EdgeEducationLevel:
		return m.clearededucation_level
	case student.EdgeEnrollmentStatus:
		return m.clearedenrollment_status
	case student.EdgeFamilyInfo:
		return m.clearedfamily_info
	case student.EdgePracticalExperience:
		return m.clearedpractical_experience
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ClearUser()
		return nil
	case student.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case student.EdgeMajor:
		m.ClearMajor()
		return nil
	case student.EdgeClass:
		m.ClearClass()
		return nil
	case student.EdgeClassLeader:
		m.ClearClassLeader()
		return nil
	case student.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ResetUser()
		return nil
	case student.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case student.EdgeMajor:
		m.ResetMajor()
		return nil
	case student.EdgeClass:
		m.ResetClass()
		return nil
	case student.EdgeClassLeader:
		m.ResetClassLeader()
		return nil
	case student.EdgeTutor:
		m.ResetTutor()
		return nil
	case student.EdgeCertificate:
		m.ResetCertificate()
		return nil
	case student.EdgeEducationLevel:
		m.ResetEducationLevel()
		return nil
	case student.EdgeEnrollmentStatus:
		m.ResetEnrollmentStatus()
		return nil
	case student.EdgeFamilyInfo:
		m.ResetFamilyInfo()
		return nil
	case student.EdgePracticalExperience:
		m.ResetPracticalExperience()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// TutorMutation represents an operation that mutates the Tutor nodes in the graph.
type TutorMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	class          *int
	clearedclass   bool
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*Tutor, error)
	predicates     []predicate.Tutor
}

var _ ent.Mutation = (*TutorMutation)(nil)

// tutorOption allows management of the mutation configuration using functional options.
type tutorOption func(*TutorMutation)

// newTutorMutation creates new mutation for the Tutor entity.
func newTutorMutation(c config, op Op, opts ...tutorOption) *TutorMutation {
	m := &TutorMutation{
		config:        c,
		op:            op,
		typ:           TypeTutor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTutorID sets the ID field of the mutation.
func withTutorID(id int) tutorOption {
	return func(m *TutorMutation) {
		var (
			err   error
			once  sync.Once
			value *Tutor
		)
		m.oldValue = func(ctx context.Context) (*Tutor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tutor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTutor sets the old Tutor of the mutation.
func withTutor(node *Tutor) tutorOption {
	return func(m *TutorMutation) {
		m.oldValue = func(context.Context) (*Tutor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TutorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TutorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TutorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TutorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tutor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *TutorMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *TutorMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *TutorMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *TutorMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *TutorMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *TutorMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *TutorMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *TutorMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *TutorMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *TutorMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *TutorMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *TutorMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the TutorMutation builder.
func (m *TutorMutation) Where(ps ...predicate.Tutor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TutorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TutorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tutor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TutorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TutorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tutor).
func (m *TutorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TutorMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TutorMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TutorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Tutor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TutorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TutorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Tutor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TutorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TutorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TutorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tutor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TutorMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TutorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, tutor.EdgeClass)
	}
	if m.student != nil {
		edges = append(edges, tutor.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TutorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case tutor.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TutorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TutorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TutorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, tutor.EdgeClass)
	}
	if m.clearedstudent {
		edges = append(edges, tutor.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TutorMutation) EdgeCleared(name string) bool {
	switch name {
	case tutor.EdgeClass:
		return m.clearedclass
	case tutor.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TutorMutation) ClearEdge(name string) error {
	switch name {
	case tutor.EdgeClass:
		m.ClearClass()
		return nil
	case tutor.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown Tutor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TutorMutation) ResetEdge(name string) error {
	switch name {
	case tutor.EdgeClass:
		m.ResetClass()
		return nil
	case tutor.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Tutor edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	account         *string
	passwd          *string
	username        *string
	avatar          *[]byte
	email           *string
	clearedFields   map[string]struct{}
	role            map[int]struct{}
	removedrole     map[int]struct{}
	clearedrole     bool
	resource        map[int]struct{}
	removedresource map[int]struct{}
	clearedresource bool
	student         *int
	clearedstudent  bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("domain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccount sets the "account" field.
func (m *UserMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *UserMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *UserMutation) ResetAccount() {
	m.account = nil
}

// SetPasswd sets the "passwd" field.
func (m *UserMutation) SetPasswd(s string) {
	m.passwd = &s
}

// Passwd returns the value of the "passwd" field in the mutation.
func (m *UserMutation) Passwd() (r string, exists bool) {
	v := m.passwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswd returns the old "passwd" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswd: %w", err)
	}
	return oldValue.Passwd, nil
}

// ResetPasswd resets all changes to the "passwd" field.
func (m *UserMutation) ResetPasswd() {
	m.passwd = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(b []byte) {
	m.avatar = &b
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r []byte, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddRoleIDs adds the "role" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.role == nil {
		m.role = make(map[int]struct{})
	}
	for i := range ids {
		m.role[ids[i]] = struct{}{}
	}
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RemoveRoleIDs removes the "role" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedrole == nil {
		m.removedrole = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role, ids[i])
		m.removedrole[ids[i]] = struct{}{}
	}
}

// RemovedRole returns the removed IDs of the "role" edge to the Role entity.
func (m *UserMutation) RemovedRoleIDs() (ids []int) {
	for id := range m.removedrole {
		ids = append(ids, id)
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
func (m *UserMutation) RoleIDs() (ids []int) {
	for id := range m.role {
		ids = append(ids, id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
	m.removedrole = nil
}

// AddResourceIDs adds the "resource" edge to the Resource entity by ids.
func (m *UserMutation) AddResourceIDs(ids ...int) {
	if m.resource == nil {
		m.resource = make(map[int]struct{})
	}
	for i := range ids {
		m.resource[ids[i]] = struct{}{}
	}
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *UserMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *UserMutation) ResourceCleared() bool {
	return m.clearedresource
}

// RemoveResourceIDs removes the "resource" edge to the Resource entity by IDs.
func (m *UserMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresource == nil {
		m.removedresource = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resource, ids[i])
		m.removedresource[ids[i]] = struct{}{}
	}
}

// RemovedResource returns the removed IDs of the "resource" edge to the Resource entity.
func (m *UserMutation) RemovedResourceIDs() (ids []int) {
	for id := range m.removedresource {
		ids = append(ids, id)
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
func (m *UserMutation) ResourceIDs() (ids []int) {
	for id := range m.resource {
		ids = append(ids, id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *UserMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
	m.removedresource = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *UserMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *UserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *UserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *UserMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *UserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.account != nil {
		fields = append(fields, user.FieldAccount)
	}
	if m.passwd != nil {
		fields = append(fields, user.FieldPasswd)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAccount:
		return m.Account()
	case user.FieldPasswd:
		return m.Passwd()
	case user.FieldUsername:
		return m.Username()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAccount:
		return m.OldAccount(ctx)
	case user.FieldPasswd:
		return m.OldPasswd(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case user.FieldPasswd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswd(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAccount:
		m.ResetAccount()
		return nil
	case user.FieldPasswd:
		m.ResetPasswd()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	if m.resource != nil {
		edges = append(edges, user.EdgeResource)
	}
	if m.student != nil {
		edges = append(edges, user.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		ids := make([]ent.Value, 0, len(m.role))
		for id := range m.role {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResource:
		ids := make([]ent.Value, 0, len(m.resource))
		for id := range m.resource {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrole != nil {
		edges = append(edges, user.EdgeRole)
	}
	if m.removedresource != nil {
		edges = append(edges, user.EdgeResource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		ids := make([]ent.Value, 0, len(m.removedrole))
		for id := range m.removedrole {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResource:
		ids := make([]ent.Value, 0, len(m.removedresource))
		for id := range m.removedresource {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	if m.clearedresource {
		edges = append(edges, user.EdgeResource)
	}
	if m.clearedstudent {
		edges = append(edges, user.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRole:
		return m.clearedrole
	case user.EdgeResource:
		return m.clearedresource
	case user.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ResetRole()
		return nil
	case user.EdgeResource:
		m.ResetResource()
		return nil
	case user.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
